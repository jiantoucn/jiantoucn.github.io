<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D é¢éƒ¨æ•æ‰ Web æ¼”ç¤º</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; font-family: sans-serif; }
        #canvas { width: 100vw; height: 100vh; display: block; }
        
        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            max-width: 300px;
        }
        
        #video-preview {
            width: 100%;
            border-radius: 4px;
            margin-top: 10px;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            background: #000;
            display: none; /* é»˜è®¤éšè—ï¼Œå¼€å¯æ‘„åƒå¤´åæ˜¾ç¤º */
        }

        input[type="text"] {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 5px;
        }
        
        button:hover { background: #0056b3; }
        button:disabled { background: #555; cursor: not-allowed; }
        
        .status { font-size: 12px; color: #aaa; margin-top: 5px; }
    </style>

    <!-- æ ¸å¿ƒä¾èµ– -->
    <!-- Cubism Core (å¿…é¡»åœ¨ pixi-live2d-display ä¹‹å‰åŠ è½½) -->
    <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
    
    <!-- PixiJS -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@6.5.1/dist/browser/pixi.min.js"></script>
    
    <!-- Pixi-Live2D-Display (ä½¿ç”¨æœ€æ–°ç‰ˆ) -->
    <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js"></script>
    
    <!-- JSZip (ç”¨äºè§£å‹æ¨¡å‹å‹ç¼©åŒ…) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Kalidokit (é¢éƒ¨è§£ç®—) -->
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>
    
    <!-- MediaPipe Face Mesh -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="ui-layer">
        <h3>Live2D é¢éƒ¨æ•æ‰</h3>
        
        <!-- æœ¬åœ°ä¸Šä¼ åŒºåŸŸ -->
        <div style="margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 15px;">
            <label style="display:block; margin-bottom:5px; font-weight:bold;">æ–¹å¼ä¸€ï¼šä¸Šä¼ æ¨¡å‹å‹ç¼©åŒ… (æ¨è)</label>
            <div style="font-size: 12px; color: #ccc; margin-bottom: 8px;">
                è¯·ä¸Šä¼ åŒ…å«æ¨¡å‹çš„ <code style="background:#444; padding:2px;">.zip</code> æ–‡ä»¶
            </div>
            <input type="file" id="file-input" accept=".zip" style="display: none;">
            <button onclick="document.getElementById('file-input').click()" style="background: #28a745;">ğŸ“¦ é€‰æ‹© ZIP å‹ç¼©åŒ…</button>
        </div>

        <!-- ç½‘ç»œé“¾æ¥åŒºåŸŸ -->
        <div style="margin-bottom: 10px;">
            <label style="display:block; margin-bottom:5px; font-weight:bold;">æ–¹å¼äºŒï¼šç½‘ç»œé“¾æ¥</label>
            <input type="text" id="model-url" placeholder="è¾“å…¥ .model3.json é“¾æ¥" value="https://cdn.jsdelivr.net/gh/guansss/pixi-live2d-display/test/assets/haru/haru_greeter_t03.model3.json">
            <button id="btn-load">ğŸŒ åŠ è½½ç½‘ç»œæ¨¡å‹</button>
        </div>

        <hr style="border-color: #444;">

        <button id="btn-camera">ğŸ“· å¼€å¯æ‘„åƒå¤´</button>
        <div class="status" id="status-text">å‡†å¤‡å°±ç»ª</div>
        
        <video id="video-preview" playsinline></video>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const { Application } = PIXI;
        // ç¡®ä¿ PIXI.live2d å­˜åœ¨
        if (!PIXI.live2d) {
            console.error("PIXI.live2d is undefined. pixi-live2d-display failed to load.");
            alert("ä¾èµ–åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚");
        }
        const { Live2DModel } = PIXI.live2d || {};
        const { Face, Vector } = Kalidokit || {};

        // å…¨å±€å˜é‡
        let currentModel = null;
        let faceMesh = null;
        let camera = null;

        // 1. åˆå§‹åŒ– Pixi åº”ç”¨
        const app = new Application({
            view: document.getElementById('canvas'),
            autoStart: true,
            resizeTo: window,
            backgroundColor: 0x202020
        });

        // 2. åŠ è½½æ¨¡å‹å‡½æ•° (æ”¯æŒ URL å­—ç¬¦ä¸²æˆ–é…ç½®å¯¹è±¡)
        async function loadModel(source) {
            const statusText = document.getElementById('status-text');
            statusText.innerText = "æ­£åœ¨åŠ è½½æ¨¡å‹...";
            
            if (!Live2DModel) {
                statusText.innerText = "é”™è¯¯: Live2DModel æœªåŠ è½½";
                return;
            }

            try {
                if (currentModel) {
                    app.stage.removeChild(currentModel);
                    currentModel.destroy();
                }

                const model = await Live2DModel.from(source);
                currentModel = model;
                app.stage.addChild(model);

                // è‡ªåŠ¨ç¼©æ”¾å’Œå®šä½
                const scaleX = (innerWidth * 0.4) / model.width;
                const scaleY = (innerHeight * 0.8) / model.height;
                const scale = Math.min(scaleX, scaleY);
                
                model.scale.set(scale);
                model.anchor.set(0.5, 0.5);
                model.position.set(innerWidth / 2, innerHeight / 2 + 100);

                statusText.innerText = "æ¨¡å‹åŠ è½½æˆåŠŸ";
                console.log("Model loaded:", model);
            } catch (e) {
                console.error(e);
                statusText.innerText = "æ¨¡å‹åŠ è½½å¤±è´¥: " + e.message;
            }
        }

        // 3. æ›´æ–° Live2D å‚æ•° (Kalidokit -> Live2D)
        function updateLive2D(riggedFace) {
            if (!currentModel || !currentModel.internalModel) return;

            const core = currentModel.internalModel.coreModel;
            const motionManager = currentModel.internalModel.motionManager;

            // è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å‚æ•°æ˜ å°„è¾…åŠ©å‡½æ•°
            const setParam = (id, value) => {
                // éƒ¨åˆ†æ¨¡å‹å¯èƒ½ä¼šæœ‰è‡ªåŠ¨çœ¨çœ¼æˆ–å‘¼å¸ï¼Œè¿™é‡Œå¯ä»¥é€‰æ‹©æ€§å…³é—­æˆ–è¦†ç›–
                 if (motionManager.expressionManager) {
                    // motionManager.expressionManager.restore(); 
                 }
                
                // å°è¯•è®¾ç½®å‚æ•°
                // Pixi-Live2d-Display å¹¶æ²¡æœ‰ç›´æ¥æš´éœ² setParameterValueById åœ¨æœ€å¤–å±‚
                // ä½†é€šå¸¸å¯ä»¥é€šè¿‡ internalModel.coreModel è®¿é—®
                if (core.setParameterValueById) {
                    core.setParameterValueById(id, value);
                } else {
                    // å…¼å®¹æ—§ç‰ˆ SDK
                    // core.setParamFloat(id, value); 
                }
            };

            // Kalidokit æä¾›äº†éå¸¸æ–¹ä¾¿çš„ Live2D å‘½åæ˜ å°„
            const head = riggedFace.head;
            const eye = riggedFace.eye;
            const mouth = riggedFace.mouth;

            // --- å¤´éƒ¨æ—‹è½¬ ---
            // Kalidokit: Y=Yaw(æ‘‡å¤´), X=Pitch(ç‚¹å¤´), Z=Roll(æ­ªå¤´)
            // Live2D: ParamAngleX(æ‘‡å¤´), ParamAngleY(ç‚¹å¤´), ParamAngleZ(æ­ªå¤´)
            // èŒƒå›´é€šå¸¸æ˜¯ -30 åˆ° 30
            
            // æ³¨æ„ï¼šæ–¹å‘å¯èƒ½éœ€è¦åè½¬
            if(core.setParameterValueById) {
                core.setParameterValueById('ParamAngleX', head.degrees.y); 
                core.setParameterValueById('ParamAngleY', head.degrees.x);
                core.setParameterValueById('ParamAngleZ', head.degrees.z);

                // --- çœ¼ç› ---
                // ParamEyeLOpen / ParamEyeROpen (0~1)
                core.setParameterValueById('ParamEyeLOpen', 1 - eye.l);
                core.setParameterValueById('ParamEyeROpen', 1 - eye.r);

                // çœ¼çƒ X/Y (-1~1)
                if (riggedFace.pupil) {
                    core.setParameterValueById('ParamEyeBallX', riggedFace.pupil.x);
                    core.setParameterValueById('ParamEyeBallY', riggedFace.pupil.y);
                }

                // --- å˜´å·´ ---
                // ParamMouthOpenY (0~1)
                core.setParameterValueById('ParamMouthOpenY', mouth.y);
                // å˜´å‹ä¿®æ­£ (å¾®ç¬‘/éš¾è¿‡)
                core.setParameterValueById('ParamMouthForm', 0.3 + mouth.x); // ç¨å¾®é»˜è®¤å¸¦ç‚¹å¾®ç¬‘

                // --- èº«ä½“ ---
                core.setParameterValueById('ParamBodyAngleX', head.degrees.y * 0.5);
                core.setParameterValueById('ParamBodyAngleY', head.degrees.x * 0.5);
                core.setParameterValueById('ParamBodyAngleZ', head.degrees.z * 0.5);
            }
        }

        // 4. åˆå§‹åŒ– MediaPipe Face Mesh
        async function initCamera() {
            const statusText = document.getElementById('status-text');
            const videoElement = document.getElementById('video-preview');
            
            statusText.innerText = "æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...";
            videoElement.style.display = "block";

            try {
                faceMesh = new FaceMesh({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }});

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults((results) => {
                    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                        const landmarks = results.multiFaceLandmarks[0];
                        
                        // ä½¿ç”¨ Kalidokit è§£ç®—
                        const riggedFace = Face.solve(landmarks, {
                            runtime: 'mediapipe',
                            video: videoElement
                        });

                        if (riggedFace) {
                            updateLive2D(riggedFace);
                        }
                    }
                });

                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });

                await camera.start();
                statusText.innerText = "æ‘„åƒå¤´æ­£åœ¨è¿è¡Œ";
                document.getElementById('btn-camera').disabled = true; // é˜²æ­¢é‡å¤ç‚¹å‡»

            } catch (err) {
                console.error(err);
                statusText.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err.message;
            }
        }

        // --- æœ¬åœ°æ–‡ä»¶å¤„ç†é€»è¾‘ (ZIP) ---
        document.getElementById('file-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const statusText = document.getElementById('status-text');
            statusText.innerText = "æ­£åœ¨è§£å‹æ¨¡å‹...";

            try {
                // 1. è§£å‹ ZIP
                const zip = await JSZip.loadAsync(file);
                
                // 2. å¯»æ‰¾æ¨¡å‹å…¥å£æ–‡ä»¶
                let modelFileEntry = null;
                let modelDir = '';

                // éå†æ‰€æœ‰æ–‡ä»¶å¯»æ‰¾ .model3.json æˆ– .model.json
                for (const [relativePath, entry] of Object.entries(zip.files)) {
                    if (entry.dir) continue;
                    if (relativePath.endsWith('.model3.json') || relativePath.endsWith('.model.json')) {
                        modelFileEntry = entry;
                        // è·å–ç›®å½•å‰ç¼€
                        const lastSlashIndex = relativePath.lastIndexOf('/');
                        if (lastSlashIndex !== -1) {
                            modelDir = relativePath.substring(0, lastSlashIndex + 1);
                        }
                        break;
                    }
                }

                if (!modelFileEntry) {
                    alert('å‹ç¼©åŒ…å†…æœªæ‰¾åˆ° .model3.json æˆ– .model.json æ–‡ä»¶');
                    statusText.innerText = "è§£å‹å¤±è´¥: æœªæ‰¾åˆ°æ¨¡å‹æ–‡ä»¶";
                    return;
                }

                // 3. å°†æ‰€æœ‰ç›¸å…³æ–‡ä»¶è½¬æ¢ä¸º Blob URL
                const fileMap = new Map();
                const conversionPromises = [];

                for (const [relativePath, entry] of Object.entries(zip.files)) {
                    if (entry.dir) continue;
                    
                    // åªå¤„ç†æ¨¡å‹ç›®å½•ä¸‹çš„æ–‡ä»¶ (å¦‚æœæ¨¡å‹åœ¨æ ¹ç›®å½•ï¼ŒmodelDir ä¸ºç©ºå­—ç¬¦ä¸²ï¼ŒstartsWith æ€»æ˜¯ true)
                    if (relativePath.startsWith(modelDir)) {
                        // å»é™¤ç›®å½•å‰ç¼€ï¼Œå¾—åˆ°ç›¸å¯¹è·¯å¾„
                        const cleanPath = relativePath.substring(modelDir.length);
                        
                        // å¼‚æ­¥è½¬æ¢ Blob
                        const p = entry.async('blob').then(blob => {
                            const blobUrl = URL.createObjectURL(blob);
                            fileMap.set(cleanPath, blobUrl);
                            fileMap.set('./' + cleanPath, blobUrl); // å…¼å®¹ ./ å†™æ³•
                        });
                        conversionPromises.push(p);
                    }
                }

                await Promise.all(conversionPromises);

                // 4. è¯»å–å¹¶è§£æä¸»æ¨¡å‹é…ç½®æ–‡ä»¶
                const jsonStr = await modelFileEntry.async('string');
                const settings = JSON.parse(jsonStr);

                // é€’å½’æ›¿æ¢è·¯å¾„
                function replacePaths(obj) {
                    if (typeof obj === 'string') {
                        if (fileMap.has(obj)) return fileMap.get(obj);
                        return obj;
                    }
                    if (Array.isArray(obj)) return obj.map(replacePaths);
                    if (typeof obj === 'object' && obj !== null) {
                        const newObj = {};
                        for (const key in obj) newObj[key] = replacePaths(obj[key]);
                        return newObj;
                    }
                    return obj;
                }

                const patchedSettings = replacePaths(settings);
                // è¡¥å…… url å±æ€§
                patchedSettings.url = fileMap.get(modelFileEntry.name.substring(modelDir.length)) || "model.json";

                console.log('åŠ è½½ ZIP æ¨¡å‹é…ç½®:', patchedSettings);
                await loadModel(patchedSettings);
                
                statusText.innerText = "ZIP æ¨¡å‹åŠ è½½æˆåŠŸ";

            } catch (err) {
                console.error(err);
                statusText.innerText = "ZIP å¤„ç†å¤±è´¥: " + err.message;
                alert('ZIP è§£æå¤±è´¥: ' + err.message);
            }
        });

        // UI äº‹ä»¶ç»‘å®š
        document.getElementById('btn-load').addEventListener('click', () => {
            const url = document.getElementById('model-url').value;
            if (url) loadModel(url);
        });

        document.getElementById('btn-camera').addEventListener('click', () => {
            initCamera();
        });

        // é»˜è®¤åŠ è½½ä¸€æ¬¡æ¨¡å‹
        window.onload = () => {
            loadModel(document.getElementById('model-url').value);
        };

        // çª—å£å¤§å°æ”¹å˜æ—¶é‡ç½®æ¨¡å‹ä½ç½®
        window.onresize = () => {
            if (currentModel) {
                 const scaleX = (innerWidth * 0.4) / currentModel.width;
                const scaleY = (innerHeight * 0.8) / currentModel.height;
                const scale = Math.min(scaleX, scaleY);
                // è¿™é‡Œå¯èƒ½éœ€è¦é‡æ–°è®¡ç®—åŸå§‹æ¯”ä¾‹ï¼Œç®€å•èµ·è§ä¸å†é‡å¤è®¾ç½®
                currentModel.position.set(innerWidth / 2, innerHeight / 2 + 100);
            }
        };

    </script>
</body>
</html>