<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D é¢éƒ¨æ•æ‰ Web æ¼”ç¤º</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007bff">
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; font-family: sans-serif; }
        #canvas { width: 100vw; height: 100vh; display: block; }
        
        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            max-width: 300px;
        }
        
        #video-preview {
            width: 100%;
            border-radius: 4px;
            margin-top: 10px;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            background: #000;
            display: none; /* é»˜è®¤éšè—ï¼Œå¼€å¯æ‘„åƒå¤´åæ˜¾ç¤º */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #output-canvas {
            width: 100%;
            border-radius: 4px;
            margin-top: 10px;
            transform: scaleX(-1);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2; /* åœ¨è§†é¢‘ä¹‹ä¸Š */
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
        }

        /* è§†é¢‘å®¹å™¨ï¼Œç”¨äºé‡å  video å’Œ canvas */
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 æ¯”ä¾‹ */
            display: none; /* åˆå§‹éšè— */
            margin-top: 10px;
        }
        
        .video-container video, .video-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        input[type="text"] {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 5px;
        }
        
        button:hover { background: #0056b3; }
        button:disabled { background: #555; cursor: not-allowed; }
        
        .status { font-size: 12px; color: #aaa; margin-top: 5px; }
    </style>

    <!-- æ ¸å¿ƒä¾èµ– -->
    <!-- Cubism Core (å¿…é¡»åœ¨ pixi-live2d-display ä¹‹å‰åŠ è½½) -->
    <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
    
    <!-- PixiJS -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@6.5.1/dist/browser/pixi.min.js"></script>
    
    <!-- Pixi-Live2D-Display (ä½¿ç”¨æœ€æ–°ç‰ˆ) -->
    <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js"></script>
    
    <!-- JSZip (ç”¨äºè§£å‹æ¨¡å‹å‹ç¼©åŒ…) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- MediaPipe Drawing Utils (ç”¨äºç»˜åˆ¶éª¨éª¼) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <!-- Kalidokit (é¢éƒ¨è§£ç®—) -->
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>
    
    <!-- MediaPipe Face Mesh -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="ui-layer">
        <h3>Live2D é¢éƒ¨æ•æ‰ <span style="font-size: 0.6em; color: #888; background: #333; padding: 2px 4px; border-radius: 4px;">v1.3</span></h3>
        
        <!-- æœ¬åœ°ä¸Šä¼ åŒºåŸŸ -->
        <div style="margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 15px;">
            <label style="display:block; margin-bottom:5px; font-weight:bold;">æ–¹å¼ä¸€ï¼šä¸Šä¼ æ¨¡å‹å‹ç¼©åŒ… (æ¨è)</label>
            <div style="font-size: 12px; color: #ccc; margin-bottom: 8px;">
                è¯·ä¸Šä¼ åŒ…å«æ¨¡å‹çš„ <code style="background:#444; padding:2px;">.zip</code> æ–‡ä»¶
            </div>
            <input type="file" id="file-input" accept=".zip" style="display: none;">
            <button onclick="document.getElementById('file-input').click()" style="background: #28a745;">ğŸ“¦ é€‰æ‹© ZIP å‹ç¼©åŒ…</button>
        </div>

        <!-- ç½‘ç»œé“¾æ¥åŒºåŸŸ -->
        <div style="margin-bottom: 10px;">
            <label style="display:block; margin-bottom:5px; font-weight:bold;">æ–¹å¼äºŒï¼šç½‘ç»œé“¾æ¥</label>
            <input type="text" id="model-url" placeholder="è¾“å…¥ .model3.json é“¾æ¥" value="https://cdn.jsdelivr.net/gh/guansss/pixi-live2d-display/test/assets/haru/haru_greeter_t03.model3.json">
            <button id="btn-load">ğŸŒ åŠ è½½ç½‘ç»œæ¨¡å‹</button>
        </div>

        <hr style="border-color: #444;">

        <button id="btn-camera">ğŸ“· å¼€å¯æ‘„åƒå¤´</button>
        <button id="btn-refresh" style="background: #6c757d; margin-top: 5px;">ğŸ”„ å¼ºåˆ¶åˆ·æ–°ç¼“å­˜</button>
        <div class="status" id="status-text">å‡†å¤‡å°±ç»ª</div>
        
        <div class="video-container" id="video-container">
            <video id="video-preview" playsinline></video>
            <canvas id="output-canvas"></canvas>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // ç‰ˆæœ¬ v1.3 - PWA æ”¯æŒ + æœ€ä¿å®ˆåˆå§‹åŒ– + éª¨éª¼å¯è§†åŒ–
        const { Application } = PIXI;
        // ç¡®ä¿ PIXI.live2d å­˜åœ¨
        if (!PIXI.live2d) {
            console.error("PIXI.live2d is undefined. pixi-live2d-display failed to load.");
            alert("ä¾èµ–åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚");
        }
        const { Live2DModel } = PIXI.live2d || {};
        const { Face, Vector } = Kalidokit || {};

        // æ³¨å†Œ Ticker (å…³é”®: è§£å†³æ¨¡å‹ä¸æ˜¾ç¤º/ä¸åŠ¨çš„é—®é¢˜)
        if (Live2DModel) {
            Live2DModel.registerTicker(PIXI.Ticker);
        }

        // å…¨å±€å˜é‡
        let currentModel = null;
        let faceMesh = null;
        let camera = null;
        let app = null;

        // 1. åˆå§‹åŒ– Pixi åº”ç”¨ (ç‹¬ç«‹å‡½æ•°)
        function initPixi() {
            app = new Application({
                view: document.getElementById('canvas'),
                autoStart: true,
                resizeTo: window,
                backgroundColor: 0x202020
            });
            console.log("Pixi initialized");
        }

        // 2. åŠ è½½æ¨¡å‹å‡½æ•° (æ”¯æŒ URL å­—ç¬¦ä¸²æˆ–é…ç½®å¯¹è±¡)
        async function loadModel(source) {
            const statusText = document.getElementById('status-text');
            statusText.innerText = "æ­£åœ¨åŠ è½½æ¨¡å‹...";
            
            if (!Live2DModel) {
                statusText.innerText = "é”™è¯¯: Live2DModel æœªåŠ è½½";
                return;
            }

            try {
                if (currentModel) {
                    app.stage.removeChild(currentModel);
                    currentModel.destroy();
                    currentModel = null;
                }

                console.log("Starting model load...");
                const model = await Live2DModel.from(source);
                
                currentModel = model;
                app.stage.addChild(model);

                // è‡ªåŠ¨ç¼©æ”¾å’Œå®šä½ (å¢åŠ å®‰å…¨æ£€æŸ¥)
                const modelWidth = model.width || 800; // é˜²æ­¢ä¸º 0
                const modelHeight = model.height || 800;
                
                // ä¿å®ˆçš„ç¼©æ”¾é€»è¾‘
                let scaleX = (innerWidth * 0.4) / modelWidth;
                let scaleY = (innerHeight * 0.8) / modelHeight;
                let scale = Math.min(scaleX, scaleY);
                
                // é˜²æ­¢ç¼©æ”¾å¼‚å¸¸
                if (!Number.isFinite(scale) || scale <= 0) {
                    scale = 0.25;
                    console.warn("æ¨¡å‹å°ºå¯¸å¼‚å¸¸ï¼Œä½¿ç”¨é»˜è®¤ç¼©æ”¾ 0.25");
                }
                
                model.scale.set(scale);
                model.anchor.set(0.5, 0.5);
                model.position.set(innerWidth / 2, innerHeight / 2 + 100);

                statusText.innerText = "æ¨¡å‹åŠ è½½æˆåŠŸ";
                console.log("Model loaded:", model);
            } catch (e) {
                console.error(e);
                statusText.innerText = "æ¨¡å‹åŠ è½½å¤±è´¥: " + e.message;
            }
        }

        // 3. æ›´æ–° Live2D å‚æ•° (Kalidokit -> Live2D)
        function updateLive2D(riggedFace) {
            if (!currentModel || !currentModel.internalModel) return;

            const core = currentModel.internalModel.coreModel;
            const motionManager = currentModel.internalModel.motionManager;

            const setParam = (id, value) => {
                 if (core.setParameterValueById) {
                    core.setParameterValueById(id, value);
                } 
            };

            const head = riggedFace.head;
            const eye = riggedFace.eye;
            const mouth = riggedFace.mouth;

            if(core.setParameterValueById) {
                core.setParameterValueById('ParamAngleX', head.degrees.y); 
                core.setParameterValueById('ParamAngleY', head.degrees.x);
                core.setParameterValueById('ParamAngleZ', head.degrees.z);
                core.setParameterValueById('ParamEyeLOpen', 1 - eye.l);
                core.setParameterValueById('ParamEyeROpen', 1 - eye.r);
                if (riggedFace.pupil) {
                    core.setParameterValueById('ParamEyeBallX', riggedFace.pupil.x);
                    core.setParameterValueById('ParamEyeBallY', riggedFace.pupil.y);
                }
                core.setParameterValueById('ParamMouthOpenY', mouth.y);
                core.setParameterValueById('ParamMouthForm', 0.3 + mouth.x);
                core.setParameterValueById('ParamBodyAngleX', head.degrees.y * 0.5);
                core.setParameterValueById('ParamBodyAngleY', head.degrees.x * 0.5);
                core.setParameterValueById('ParamBodyAngleZ', head.degrees.z * 0.5);
            }
        }

        // 4. åˆå§‹åŒ– MediaPipe Face Mesh
        async function initCamera() {
            const statusText = document.getElementById('status-text');
            const videoElement = document.getElementById('video-preview');
            const canvasElement = document.getElementById('output-canvas');
            const canvasCtx = canvasElement.getContext('2d');
            const videoContainer = document.getElementById('video-container');
            
            statusText.innerText = "æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...";
            videoContainer.style.display = "block";

            try {
                faceMesh = new FaceMesh({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }});

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults((results) => {
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    
                    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                        const landmarks = results.multiFaceLandmarks[0];

                        // ç»˜åˆ¶é¢éƒ¨ç½‘æ ¼
                        if (window.drawConnectors && window.drawLandmarks) {
                            drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
                            drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
                            drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, {color: '#FF3030'});
                            drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
                            drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, {color: '#30FF30'});
                            drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, {color: '#E0E0E0'});
                            drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, {color: '#E0E0E0'});
                        }

                        const riggedFace = Face.solve(landmarks, {
                            runtime: 'mediapipe',
                            video: videoElement
                        });

                        if (riggedFace) {
                            updateLive2D(riggedFace);
                        }
                    }
                    canvasCtx.restore();
                });

                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });

                camera.camera_ = { ...camera.camera_, width: 640, height: 480 }; 
                canvasElement.width = 640;
                canvasElement.height = 480;

                await camera.start();
                statusText.innerText = "æ‘„åƒå¤´æ­£åœ¨è¿è¡Œ (v1.1)";
                document.getElementById('btn-camera').disabled = true;

            } catch (err) {
                console.error(err);
                statusText.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err.message;
            }
        }

        // --- æœ¬åœ°æ–‡ä»¶å¤„ç†é€»è¾‘ (ZIP) ---
        document.getElementById('file-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const statusText = document.getElementById('status-text');
            statusText.innerText = "æ­£åœ¨è§£å‹æ¨¡å‹...";

            try {
                // 1. è§£å‹ ZIP
                const zip = await JSZip.loadAsync(file);
                
                // 2. å¯»æ‰¾æ¨¡å‹å…¥å£æ–‡ä»¶
                let modelFileEntry = null;
                let modelDir = '';

                // éå†æ‰€æœ‰æ–‡ä»¶å¯»æ‰¾ .model3.json æˆ– .model.json
                for (const [relativePath, entry] of Object.entries(zip.files)) {
                    if (entry.dir) continue;
                    if (relativePath.endsWith('.model3.json') || relativePath.endsWith('.model.json')) {
                        modelFileEntry = entry;
                        // è·å–ç›®å½•å‰ç¼€
                        const lastSlashIndex = relativePath.lastIndexOf('/');
                        if (lastSlashIndex !== -1) {
                            modelDir = relativePath.substring(0, lastSlashIndex + 1);
                        }
                        break;
                    }
                }

                if (!modelFileEntry) {
                    alert('å‹ç¼©åŒ…å†…æœªæ‰¾åˆ° .model3.json æˆ– .model.json æ–‡ä»¶');
                    statusText.innerText = "è§£å‹å¤±è´¥: æœªæ‰¾åˆ°æ¨¡å‹æ–‡ä»¶";
                    return;
                }

                // 3. å°†æ‰€æœ‰ç›¸å…³æ–‡ä»¶è½¬æ¢ä¸º Blob URL
                const fileMap = new Map();
                const conversionPromises = [];

                for (const [relativePath, entry] of Object.entries(zip.files)) {
                    if (entry.dir) continue;
                    
                    // åªå¤„ç†æ¨¡å‹ç›®å½•ä¸‹çš„æ–‡ä»¶ (å¦‚æœæ¨¡å‹åœ¨æ ¹ç›®å½•ï¼ŒmodelDir ä¸ºç©ºå­—ç¬¦ä¸²ï¼ŒstartsWith æ€»æ˜¯ true)
                    if (relativePath.startsWith(modelDir)) {
                        // å»é™¤ç›®å½•å‰ç¼€ï¼Œå¾—åˆ°ç›¸å¯¹è·¯å¾„
                        const cleanPath = relativePath.substring(modelDir.length);
                        
                        // å¼‚æ­¥è½¬æ¢ Blob
                        const p = entry.async('blob').then(blob => {
                            const blobUrl = URL.createObjectURL(blob);
                            fileMap.set(cleanPath, blobUrl);
                            fileMap.set('./' + cleanPath, blobUrl); // å…¼å®¹ ./ å†™æ³•
                        });
                        conversionPromises.push(p);
                    }
                }

                await Promise.all(conversionPromises);

                // 4. è¯»å–å¹¶è§£æä¸»æ¨¡å‹é…ç½®æ–‡ä»¶
                const jsonStr = await modelFileEntry.async('string');
                const settings = JSON.parse(jsonStr);

                // é€’å½’æ›¿æ¢è·¯å¾„
                function replacePaths(obj) {
                    if (typeof obj === 'string') {
                        if (fileMap.has(obj)) return fileMap.get(obj);
                        return obj;
                    }
                    if (Array.isArray(obj)) return obj.map(replacePaths);
                    if (typeof obj === 'object' && obj !== null) {
                        const newObj = {};
                        for (const key in obj) newObj[key] = replacePaths(obj[key]);
                        return newObj;
                    }
                    return obj;
                }

                const patchedSettings = replacePaths(settings);
                // è¡¥å…… url å±æ€§
                patchedSettings.url = fileMap.get(modelFileEntry.name.substring(modelDir.length)) || "model.json";

                console.log('åŠ è½½ ZIP æ¨¡å‹é…ç½®:', patchedSettings);
                await loadModel(patchedSettings);
                
                statusText.innerText = "ZIP æ¨¡å‹åŠ è½½æˆåŠŸ";

            } catch (err) {
                console.error(err);
                statusText.innerText = "ZIP å¤„ç†å¤±è´¥: " + err.message;
                alert('ZIP è§£æå¤±è´¥: ' + err.message);
            }
        });

        // å¯åŠ¨é€»è¾‘
        initPixi(); // ç«‹å³åˆå§‹åŒ– Pixi

        // æ³¨å†Œ Service Worker (PWA)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then(registration => {
                    console.log('SW registered: ', registration);
                }).catch(registrationError => {
                    console.log('SW registration failed: ', registrationError);
                });
            });
        }

        // UI äº‹ä»¶ç»‘å®š
        document.getElementById('btn-load').addEventListener('click', () => {
            const url = document.getElementById('model-url').value;
            if (url) loadModel(url);
        });

        document.getElementById('btn-camera').addEventListener('click', () => {
            initCamera();
        });

        document.getElementById('btn-refresh').addEventListener('click', () => {
            // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„ Service Worker (å¦‚æœæœªæ¥æ·»åŠ äº†)
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    for (let registration of registrations) {
                        registration.unregister();
                    }
                });
            }
            // å¼ºåˆ¶é‡æ–°åŠ è½½é¡µé¢
            window.location.reload(true);
        });

        // é»˜è®¤åŠ è½½ä¸€æ¬¡æ¨¡å‹
        window.onload = () => {
            loadModel(document.getElementById('model-url').value);
        };

        // çª—å£å¤§å°æ”¹å˜æ—¶é‡ç½®æ¨¡å‹ä½ç½®
        window.onresize = () => {
            if (currentModel) {
                 const scaleX = (innerWidth * 0.4) / (currentModel.width || 800);
                const scaleY = (innerHeight * 0.8) / (currentModel.height || 800);
                const scale = Math.min(scaleX, scaleY);
                // è¿™é‡Œå¯èƒ½éœ€è¦é‡æ–°è®¡ç®—åŸå§‹æ¯”ä¾‹ï¼Œç®€å•èµ·è§ä¸å†é‡å¤è®¾ç½®
                currentModel.position.set(innerWidth / 2, innerHeight / 2 + 100);
            }
        };
    </script>
</body>
</html>