# 瑞士轮计算算法说明文档

本项目实现的瑞士轮计算引擎旨在为竞赛组织者和选手提供精确的晋级预测。以下是核心算法逻辑的详细说明：

## 1. 核心逻辑：战绩分布模拟

由于瑞士轮比赛中每一轮都是基于当前战绩进行配对，选手的战绩分布遵循特定的概率模型。我们使用**基于分布的迭代算法**来模拟每一轮后的选手状态：

- **初始状态**：所有选手从 0 胜 0 负开始。
- **轮次迭代**：对于每一轮：
  - 将每个分数段（例如 2-1）的选手按同分匹配。
  - **胜负分配**：同分数段内，一半人获胜进入下一分数段（3-1），另一半人落败（2-2）。
  - **向下匹配（Down-pairing）**：如果某个分数段人数为奇数，其中一人将“向下匹配”到下一个分数段。
  - **轮空机制（Bye）**：如果全场总人数为奇数，最低分数段中未能配对的一名选手将获得“轮空”，计为 1 胜。

## 2. 晋级分析逻辑

在所有轮次模拟完成后，算法根据 `TOP CUT` 名额从高分到低分进行结算：

- **稳进线 (Guaranteed Wins)**：指该战绩及以上的所有选手人数总和仍小于或等于 `TOP CUT` 名额。这些选手 100% 晋级。
- **博弈线 (Promotion Line)**：指在该战绩下，只有部分选手能晋级（因为该段累计人数超过了 `TOP CUT`）。
- **晋级概率计算**：
  - `晋级率 = (剩余名额 / 该战绩段总人数) * 100%`
  - 例如：TOP 8 名额，6-0 有 1 人，5-1 有 10 人。6-0 稳进，5-1 的 10 人争夺剩余 7 个名额，晋级率为 70%。

## 3. 算法特性

- **严格同分优先**：模拟过程确保了最大程度的同分对局。
- **无平局/无双败**：符合现代竞技比赛（如宝可梦 TCG、万智牌等）的常规瑞士轮变体要求。
- **高效计算**：采用 Map 数据结构存储分布，即使面对数万名选手的模拟也能在毫秒级完成。

## 4. 局限性说明

本工具基于理想化的分布模拟。实际比赛中，由于对手分（OMW%）的随机性以及可能出现的选手退赛，实际的晋级情况可能与模拟结果有细微偏差（通常在博弈线附近）。
