<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>单机德州王</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a1a">
    <link rel="apple-touch-icon" href="https://img.icons8.com/emoji/96/spade-suit.png">
    <link rel="icon" type="image/png" href="https://img.icons8.com/emoji/32/spade-suit.png">
    <style>
        :root {
            --table-green: radial-gradient(circle, #2e7d32 0%, #1b5e20 100%);
            --felt-color: #245a27;
            --border-wood: #5d4037;
            --card-white: #ffffff;
            --card-back: #c62828;
            --player-bg: rgba(0, 0, 0, 0.6);
            --highlight-color: #ffeb3b;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: "Microsoft YaHei", sans-serif; }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
        }

        body {
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 主布局 */
        #main-layout {
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background: #1a1a1a;
        }

        /* 游戏容器 */
        #game-container {
            position: relative;
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            align-items: center;
            padding: 80px; /* 增加内边距，给外部座位腾出充足空间 */
            min-width: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #2a2a2a 0%, #1a1a1a 100%);
        }

        /* 牌桌区域 */
        #poker-table {
            position: relative;
            width: 100%;
            max-width: 950px;
            max-height: 70vh;
            aspect-ratio: 1.9 / 1; /* 1.9:1 的比例最适合 8 人横向分布 */
            background: var(--table-green);
            border: 12px solid var(--border-wood);
            border-radius: 250px; /* 增加圆角，形成优美的椭圆 */
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5), 0 10px 20px rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 1;
        }

        /* 公共牌区 */
        #community-cards {
            display: flex;
            gap: 10px;
            perspective: 1000px;
        }

        /* 锅底/池 */
        #pot-container {
            position: absolute;
            top: 10%; /* 向上微调，给 AI 4 筹码留出空间 */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 1.1rem;
            color: #ffd700;
            font-weight: bold;
            z-index: 30;
            border: 1px solid rgba(255,215,0,0.3);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        /* 玩家位置 */
        .player-seat {
            position: absolute;
            width: 105px; /* 稍微缩小座位宽度以减少拥挤 */
            text-align: center;
            z-index: 5;
        }

        .player-seat.active {
            filter: drop-shadow(0 0 10px var(--highlight-color));
        }

        /* AI 思考中状态：亮蓝色 */
        .player-seat.thinking {
            filter: drop-shadow(0 0 10px #00f2ff) !important;
        }
        .player-seat.thinking .player-info { 
            border-color: #00f2ff !important;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.5);
        }

        /* 8人环绕布局：将座位推离中心 */
        .player-seat.bottom { bottom: -65px; left: 50%; transform: translateX(-50%); }
        .player-seat.bottom-left { bottom: 5%; left: -30px; }
        .player-seat.left   { left: -100px; top: 50%; transform: translateY(-50%); }
        .player-seat.top-left { top: 5%; left: -30px; }
        .player-seat.top    { top: -65px; left: 50%; transform: translateX(-50%); }
        .player-seat.top-right { top: 5%; right: -30px; }
        .player-seat.right  { right: -100px; top: 50%; transform: translateY(-50%); }
        .player-seat.bottom-right { bottom: 5%; right: -30px; }

        /* 筹码相对于座位的默认位置 (Desktop) */
        .player-seat.bottom .chip-stack { bottom: 115%; left: 50%; transform: translateX(-50%); }
        .player-seat.bottom-left .chip-stack { bottom: 30%; left: 115%; }
        .player-seat.left .chip-stack { left: 115%; top: 50%; transform: translateY(-50%); }
        .player-seat.top-left .chip-stack { top: 30%; left: 115%; }
         .player-seat.top .chip-stack { left: 115%; top: 50%; transform: translateY(-50%); }
         .player-seat.top-right .chip-stack { top: 30%; right: 115%; }
        .player-seat.right .chip-stack { right: 115%; top: 50%; transform: translateY(-50%); }
        .player-seat.bottom-right .chip-stack { bottom: 30%; right: 115%; }

        .player-info {
            background: var(--player-bg);
            padding: 8px;
            border-radius: 10px;
            border: 2px solid #444;
            margin-bottom: 5px;
        }
        .player-seat.active .player-info { border-color: var(--highlight-color); }

        .player-name { font-size: 0.9rem; margin-bottom: 2px; }
        .player-chips { color: #ffd700; font-weight: bold; font-size: 1rem; }
        .player-status { font-size: 0.8rem; color: #aaa; height: 1.2em; }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            height: 60px;
        }

        /* 卡牌样式 */
        .card {
            width: 45px;
            height: 65px;
            background: white;
            border-radius: 5px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 3px;
            color: black;
            font-weight: bold;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            user-select: none;
        }

        .card.red { color: #d32f2f; }
        .card.black { color: #000; }
        .card.hidden {
            background: var(--card-back);
            background-image: radial-gradient(circle, #fff 10%, transparent 10%), radial-gradient(circle, #fff 10%, transparent 10%);
            background-size: 10px 10px;
            background-position: 0 0, 5px 5px;
        }
        .card.hidden * { visibility: hidden; }

        .card-rank { font-size: 1.1rem; line-height: 1; }
        .card-suit { font-size: 1.2rem; align-self: flex-end; line-height: 1; }

        /* 筹码样式 */
        .chip-stack {
            position: absolute;
            font-size: 0.8rem;
            color: white;
            font-weight: bold;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            pointer-events: none;
        }
        .chip {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.5);
            margin-top: -15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .chip-label { margin-bottom: 2px; text-shadow: 1px 1px 2px black; }

        /* 操作面板 */
        #controls {
            width: 100%;
            max-width: 900px;
            background: #222;
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            border-top: 2px solid #444;
            border-radius: 10px;
            margin-top: 10px;
            flex-shrink: 0;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            background: #444;
            color: white;
        }
        button:hover:not(:disabled) { background: #666; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button.primary { background: #2e7d32; }
        button.primary:hover:not(:disabled) { background: #388e3c; }
        button.danger { background: #c62828; }
        button.danger:hover:not(:disabled) { background: #d32f2f; }
        button.warning { background: #f57c00; }
        button.warning:hover:not(:disabled) { background: #ff9800; }
        button.info { background: #0288d1; }
        button.info:hover:not(:disabled) { background: #03a9f4; }

        .mobile-only { display: none; }

        #raise-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #333;
            padding: 5px 15px;
            border-radius: 20px;
        }
        input[type="range"] { cursor: pointer; }
        #raise-amount-input {
            width: 80px;
            background: #222;
            border: 1px solid #555;
            color: #ffd700;
            font-weight: bold;
            border-radius: 5px;
            padding: 2px 5px;
            text-align: center;
            outline: none;
        }
        #raise-amount-input::-webkit-inner-spin-button,
        #raise-amount-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
        }
        #raise-amount-input {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        /* 弹窗 */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal {
            background: #333;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            text-align: center;
            border: 2px solid #555;
        }
        .modal h2 { margin-bottom: 20px; color: #ffd700; }
        .form-group { margin-bottom: 15px; text-align: left; }
        .form-group label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
        .form-group input {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            background: #222;
            color: white;
            -moz-appearance: textfield;
            appearance: textfield;
        }
        .form-group input::-webkit-inner-spin-button,
        .form-group input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .hidden { display: none !important; }

        /* 提示信息 */
        #game-msg {
            position: absolute;
            top: 40%; /* 移动到 40% 避免与顶部 AI 2 重叠 */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 10px rgba(0,0,0,1);
            z-index: 100; /* 提高层级 */
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #game-msg.show { opacity: 1; }

        /* 响应式 */
        @media screen and (max-width: 768px) {
            #main-layout { flex-direction: column; overflow: hidden; height: 100dvh; }
            .mobile-only { display: inline-block; }
            #close-log.mobile-only { display: flex; align-items: center; justify-content: center; }

            #game-log-container { 
                display: none !important; 
                visibility: hidden; 
                width: 0; 
                height: 0; 
                position: absolute;
            } 
            #game-log-container.active-mobile {
                display: flex !important;
                visibility: visible;
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100dvh;
                z-index: 200;
                background: rgba(0,0,0,0.95);
                margin: 0;
                border: none;
                border-radius: 0;
            }
            #game-log-header { padding: 15px; font-size: 1.2rem; }
            #game-log-body { flex: 1; font-size: 1rem; }

            #game-container { 
                height: 100%; 
                width: 100vw; 
                flex: 1;
                padding: 30px 5px; 
                overflow: hidden;
            }
            #poker-table { 
                width: 92%; 
                border-radius: 50px; 
                border-width: 6px; 
                max-height: 42vh; 
                margin-top: 20px;
                aspect-ratio: 0.9 / 1; 
            }
            #pot-container { 
                top: 5px; 
                left: 50%; 
                transform: translateX(-50%);
                font-size: 0.85rem;
                padding: 3px 8px;
            }
            .player-seat { width: 66px; } 
            .player-info { padding: 2px; border-radius: 5px; }
            .player-name { font-size: 0.55rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
            .player-chips { font-size: 0.6rem; }
            .player-status { font-size: 0.55rem; height: 1.2em; }
            .card { width: 24px; height: 34px; padding: 1px; }
            .card-rank { font-size: 0.6rem; }
            .card-suit { font-size: 0.7rem; }
            
            .player-seat.bottom { bottom: -42px; left: 50%; transform: translateX(-50%); }
            .player-seat.bottom-left { bottom: 2%; left: -28px; }
            .player-seat.left { left: -42px; top: 50%; transform: translateY(-50%); }
            .player-seat.top-left { top: 2%; left: -28px; }
            .player-seat.top { top: -42px; left: 50%; transform: translateX(-50%); }
            .player-seat.top-right { top: 2%; right: -28px; }
            .player-seat.right { right: -42px; top: 50%; transform: translateY(-50%); }
            .player-seat.bottom-right { bottom: 2%; right: -28px; }

            #controls { 
                padding: 8px 4px; 
                gap: 4px; 
                margin-top: auto;
                background: rgba(30, 30, 30, 0.98);
                border-radius: 12px 12px 0 0;
                width: 100%;
                z-index: 50;
                flex-wrap: wrap;
                justify-content: center;
            }
            button { 
                padding: 6px 2px; 
                font-size: 0.68rem; 
                height: 38px;
                flex: 1 1 30%; 
                min-width: 80px;
            }
            #raise-slider-container { 
                width: 100%; 
                justify-content: center; 
                order: -1; 
                margin-bottom: 4px;
                padding: 0 10px;
            }
            #raise-slider { flex: 1; }
            #raise-amount-input { width: 50px; height: 30px; font-size: 0.8rem; }

            .player-seat.bottom .chip-stack { bottom: 105%; left: 50%; transform: translateX(-50%); }
            .player-seat.bottom-left .chip-stack { bottom: 50%; left: 105%; transform: translateY(50%); }
            .player-seat.left .chip-stack { left: 110%; top: 50%; transform: translateY(-50%); }
            .player-seat.top-left .chip-stack { top: 50%; left: 105%; transform: translateY(-50%); }
            .player-seat.top .chip-stack { left: 110%; top: 50%; transform: translateY(-50%); }
            .player-seat.top-right .chip-stack { top: 50%; right: 105%; transform: translateY(-50%); }
            .player-seat.right .chip-stack { right: 110%; top: 50%; transform: translateY(-50%); }
            .player-seat.bottom-right .chip-stack { bottom: 50%; right: 105%; transform: translateY(50%); }
        }

        /* 针对超窄屏幕（竖屏） */
        @media (max-width: 450px) {
            #poker-table { aspect-ratio: 0.85 / 1; }
            .player-seat { width: 65px; }
            .card { width: 26px; height: 38px; }
            #pot-container { 
                top: 5px; 
                left: 50%; 
                transform: translateX(-50%); 
                font-size: 0.75rem; 
                padding: 3px 8px; 
            }
            #community-cards { gap: 3px; }
        }

        @media (max-height: 600px) {
            #poker-table { max-height: 60vh; }
            #controls { padding: 5px; margin-top: 5px; }
            .player-seat { width: 80px; }
            .player-cards { height: 40px; }
            .card { width: 30px; height: 45px; }
        }

        /* 游戏日志面板 */
        #game-log-container {
            width: 300px;
            background: rgba(20, 20, 20, 0.95);
            border-left: 2px solid #444;
            display: flex;
            flex-direction: column;
            font-size: 0.9rem;
            color: #ccc;
            height: 100%;
            flex-shrink: 0;
        }
        #game-log-header {
            padding: 10px;
            background: #333;
            font-weight: bold;
            color: #ffd700;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
        }
        #game-log-body {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .log-entry {
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 3px;
            line-height: 1.4;
            word-break: break-all;
        }
        .log-entry.win { color: #4caf50; font-weight: bold; }
        .log-entry.loss { color: #f44336; }
        .log-entry.thought { color: #aaa; font-style: italic; font-size: 0.85rem; }
        .log-entry.action { color: #fff; }
        .log-entry.system { color: #ffd700; font-style: italic; }

        /* 清除缓存按钮 */
        #btn-clear-cache {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            color: #aaa;
            font-size: 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        #btn-clear-cache:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-color: #666;
        }
    </style>
</head>
<body>

<button id="btn-clear-cache" title="清除缓存并强制刷新">重新开始</button>

<div id="main-layout">
    <div id="game-container">
    <div id="poker-table">
        <div id="game-msg">轮到你行动</div>
        
        <div id="pot-container">底池: <span id="main-pot">0</span></div>

        <!-- 社区牌 -->
        <div id="community-cards"></div>

        <!-- 玩家位置 -->
        <div id="seat-0" class="player-seat bottom">
            <div class="player-status" id="status-0"></div>
            <div class="player-info">
                <div class="player-name" id="name-0">你 (玩家)</div>
                <div class="player-chips" id="chips-0">10000</div>
            </div>
            <div class="player-cards" id="cards-0"></div>
            <div class="chip-stack" id="bet-0"></div>
        </div>

        <div id="seat-1" class="player-seat bottom-left">
            <div class="player-status" id="status-1"></div>
            <div class="player-info">
                <div class="player-name" id="name-1">AI 1</div>
                <div class="player-chips" id="chips-1">10000</div>
            </div>
            <div class="player-cards" id="cards-1"></div>
            <div class="chip-stack" id="bet-1"></div>
        </div>

        <div id="seat-2" class="player-seat left">
            <div class="player-status" id="status-2"></div>
            <div class="player-info">
                <div class="player-name" id="name-2">AI 2</div>
                <div class="player-chips" id="chips-2">10000</div>
            </div>
            <div class="player-cards" id="cards-2"></div>
            <div class="chip-stack" id="bet-2"></div>
        </div>

        <div id="seat-3" class="player-seat top-left">
            <div class="player-status" id="status-3"></div>
            <div class="player-info">
                <div class="player-name" id="name-3">AI 3</div>
                <div class="player-chips" id="chips-3">10000</div>
            </div>
            <div class="player-cards" id="cards-3"></div>
            <div class="chip-stack" id="bet-3"></div>
        </div>

        <div id="seat-4" class="player-seat top">
            <div class="player-status" id="status-4"></div>
            <div class="player-info">
                <div class="player-name" id="name-4">AI 4</div>
                <div class="player-chips" id="chips-4">10000</div>
            </div>
            <div class="player-cards" id="cards-4"></div>
            <div class="chip-stack" id="bet-4"></div>
        </div>

        <div id="seat-5" class="player-seat top-right">
            <div class="player-status" id="status-5"></div>
            <div class="player-info">
                <div class="player-name" id="name-5">AI 5</div>
                <div class="player-chips" id="chips-5">10000</div>
            </div>
            <div class="player-cards" id="cards-5"></div>
            <div class="chip-stack" id="bet-5"></div>
        </div>

        <div id="seat-6" class="player-seat right">
            <div class="player-status" id="status-6"></div>
            <div class="player-info">
                <div class="player-name" id="name-6">AI 6</div>
                <div class="player-chips" id="chips-6">10000</div>
            </div>
            <div class="player-cards" id="cards-6"></div>
            <div class="chip-stack" id="bet-6"></div>
        </div>

        <div id="seat-7" class="player-seat bottom-right">
            <div class="player-status" id="status-7"></div>
            <div class="player-info">
                <div class="player-name" id="name-7">AI 7</div>
                <div class="player-chips" id="chips-7">10000</div>
            </div>
            <div class="player-cards" id="cards-7"></div>
            <div class="chip-stack" id="bet-7"></div>
        </div>
    </div>

    <!-- 操作面板 -->
    <div id="controls" class="hidden">
        <button id="btn-log" class="info mobile-only">日志</button>
        <button id="btn-fold" class="danger" disabled>弃牌</button>
        <button id="btn-check" disabled>看牌</button>
        <button id="btn-call" disabled>跟注 <span id="call-amount"></span></button>
        <div id="raise-slider-container">
            <input type="number" id="raise-amount-input" value="0" disabled>
            <input type="range" id="raise-slider" min="0" max="1000" step="50" disabled>
        </div>
        <button id="btn-raise" class="warning" disabled>加注</button>
        <button id="btn-allin" class="primary" disabled>全下</button>
    </div>

    </div>

    <!-- 游戏日志 -->
    <div id="game-log-container">
        <div id="game-log-header">
            <span>游戏日志</span>
            <span id="hand-number">局数: 0</span>
            <span id="close-log" class="mobile-only" style="cursor: pointer; font-size: 1.5rem;">&times;</span>
        </div>
        <div id="game-log-body">
            <div class="log-entry system">欢迎来到德州扑克！</div>
        </div>
    </div>
</div>

<!-- 设置模态框 -->
<div id="setup-modal" class="modal-overlay">
    <div class="modal">
        <h2>游戏设置</h2>
        <div class="form-group">
                <label>你的名字</label>
                <input type="text" id="player-name" value="玩家" placeholder="输入你的大名">
            </div>
            <div class="form-group">
            <label>起始筹码</label>
            <input type="number" id="start-chips" value="10000" min="1000" step="500">
        </div>
        <div class="form-group">
            <label>小盲注金额</label>
            <input type="number" id="small-blind" value="50" min="10" step="10">
        </div>
        <div class="form-group">
            <label>AI 平台选择</label>
            <select id="ai-platform" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #555; background: #222; color: white;">
                <option value="siliconflow" selected>硅基流动 (SiliconFlow)</option>
                <option value="deepseek">DeepSeek</option>
            </select>
        </div>
        <div class="form-group">
            <label>AI 模型选择</label>
            <select id="ai-model" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #555; background: #222; color: white;">
                <option value="Qwen/Qwen2.5-7B-Instruct" selected>Qwen/Qwen2.5-7B-Instruct (默认)</option>
                <option value="deepseek-ai/DeepSeek-V3.2">deepseek-ai/DeepSeek-V3.2</option>
                <option value="moonshotai/Kimi-K2-Thinking">moonshotai/Kimi-K2-Thinking</option>
                <option value="Qwen/Qwen3-VL-32B-Instruct">Qwen/Qwen3-VL-32B-Instruct</option>
            </select>
        </div>
        <div class="form-group">
            <label>API Key</label>
            <input type="password" id="api-key" placeholder="输入 API Key" value="sk-yomwzgtkkyluoafqpevyolskpgcwgipehqoqggmfedmoxfou">
        </div>
        <button id="start-game-btn" class="primary" style="width: 100%;">开始游戏</button>
        <div style="text-align: center; margin-top: 15px; font-size: 0.65rem; color: #666; opacity: 0.8; letter-spacing: 0.5px;">
            Designed and Deployed By Sayaka, Coded By Gemini 3
        </div>
    </div>
</div>

<!-- 结算模态框 -->
<div id="result-modal" class="modal-overlay hidden">
    <div class="modal">
        <h2 id="result-title">游戏结束</h2>
        <p id="result-body" style="margin-bottom: 20px; line-height: 1.6;"></p>
        <button id="restart-game-btn" class="primary" style="width: 100%;">重新开始</button>
    </div>
</div>

<script>
/**
 * 德州扑克核心引擎
 */

// 常量定义
const SUITS = ['♠', '♥', '♣', '♦'];
const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
const RANK_VALUES = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };

const HAND_TYPES = {
    ROYAL_FLUSH: 9,
    STRAIGHT_FLUSH: 8,
    FOUR_OF_A_KIND: 7,
    FULL_HOUSE: 6,
    FLUSH: 5,
    STRAIGHT: 4,
    THREE_OF_A_KIND: 3,
    TWO_PAIR: 2,
    PAIR: 1,
    HIGH_CARD: 0
};

const HAND_NAMES = ["高牌", "一对", "两对", "三条", "顺子", "同花", "葫芦", "四条", "同花顺", "皇家同花顺"];

// 游戏状态
let gameState = {
    players: [],
    deck: [],
    communityCards: [],
    pot: 0,
    currentBet: 0,
    minRaise: 0,
    dealerIndex: 0,
    currentPlayerIndex: 0,
    stage: 'preflop', // preflop, flop, turn, river, showdown
    smallBlind: 50,
    bigBlind: 100,
    handCount: 0,
    activePlayersCount: 0,
    lastRaiserIndex: -1,
    actionHistory: [], // 记录本局动作历史
    winners: []
};

/**
 * 卡牌类
 */
class Card {
    constructor(suit, rank) {
        this.suit = suit;
        this.rank = rank;
        this.value = RANK_VALUES[rank];
        this.color = (suit === '♥' || suit === '♦') ? 'red' : 'black';
    }
}

/**
 * 玩家类
 */
class Player {
    constructor(id, name, chips, isAI = true) {
        this.id = id;
        this.name = name;
        this.chips = chips;
        this.isAI = isAI;
        this.cards = [];
        this.currentBet = 0;
        this.isFolded = false;
        this.isAllIn = false;
        this.hasActed = false;
        this.totalContributed = 0; // 本局总投入，用于计算副池
        this.handResult = null;
        
        // AI 独立性格系统
        if (isAI) {
            this.refreshPersonality();
        }
    }

    // 独立思考：刷新 AI 的性格底色、激进度和稳定性
    refreshPersonality() {
        const personalities = ['tight-passive', 'loose-aggressive', 'balanced'];
        this.personality = personalities[Math.floor(Math.random() * personalities.length)];
        // 激进指数 (0-1)：调整为 0.2-0.8 之间，避免极度极端
        this.aggression = 0.2 + Math.random() * 0.6; 
        // 稳定性 (0-1)：越低越容易在出牌中途“变脸”
        this.stability = 0.5 + Math.random() * 0.5; 
        // 实时情绪 (-0.3 到 0.3)：减少情绪波动对激进度的极端影响
        this.mood = (Math.random() - 0.5) * 0.6; 
    }

    // 动态调整情绪
    updateMood() {
        // 每一次行动，AI 都有概率改变当下的主意
        const swing = (Math.random() - 0.5) * (1.1 - this.stability);
        this.mood = Math.max(-1, Math.min(1, this.mood + swing));
    }
}

/**
 * 牌型判定逻辑
 */
class HandEvaluator {
    static evaluate(cards) {
        const combinations = this.getCombinations(cards, 5);
        let bestHand = null;

        for (const combo of combinations) {
            const result = this.getHandStrength(combo);
            if (!bestHand || this.compareResults(result, bestHand) > 0) {
                bestHand = result;
            }
        }
        return bestHand;
    }

    // 获取所有5张牌的组合 (7选5)
    static getCombinations(array, k) {
        const result = [];
        const f = (start, combo) => {
            if (combo.length === k) {
                result.push([...combo]);
                return;
            }
            for (let i = start; i < array.length; i++) {
                combo.push(array[i]);
                f(i + 1, combo);
                combo.pop();
            }
        };
        f(0, []);
        return result;
    }

    static getHandStrength(cards) {
        const sorted = [...cards].sort((a, b) => b.value - a.value);
        const isFlush = new Set(sorted.map(c => c.suit)).size === 1;
        
        // 顺子判定 (处理 A2345)
        let isStraight = true;
        let straightHighValue = sorted[0].value;
        for (let i = 0; i < sorted.length - 1; i++) {
            if (sorted[i].value !== sorted[i+1].value + 1) {
                isStraight = false;
                break;
            }
        }
        // 特殊处理 A2345
        if (!isStraight && sorted[0].value === 14 && sorted[1].value === 5 && sorted[2].value === 4 && sorted[3].value === 3 && sorted[4].value === 2) {
            isStraight = true;
            straightHighValue = 5;
        }

        const counts = {};
        sorted.forEach(c => counts[c.value] = (counts[c.value] || 0) + 1);
        const countValues = Object.values(counts).sort((a, b) => b - a);
        const rankEntries = Object.entries(counts).map(([val, count]) => ({ val: parseInt(val), count })).sort((a, b) => b.count !== a.count ? b.count - a.count : b.val - a.val);

        if (isFlush && isStraight) {
            return { type: straightHighValue === 14 ? HAND_TYPES.ROYAL_FLUSH : HAND_TYPES.STRAIGHT_FLUSH, value: straightHighValue, kickers: [] };
        }
        if (countValues[0] === 4) {
            return { type: HAND_TYPES.FOUR_OF_A_KIND, value: rankEntries[0].val, kickers: [rankEntries[1].val] };
        }
        if (countValues[0] === 3 && countValues[1] === 2) {
            return { type: HAND_TYPES.FULL_HOUSE, value: rankEntries[0].val, kickers: [rankEntries[1].val] };
        }
        if (isFlush) {
            return { type: HAND_TYPES.FLUSH, value: 0, kickers: sorted.map(c => c.value) };
        }
        if (isStraight) {
            return { type: HAND_TYPES.STRAIGHT, value: straightHighValue, kickers: [] };
        }
        if (countValues[0] === 3) {
            return { type: HAND_TYPES.THREE_OF_A_KIND, value: rankEntries[0].val, kickers: [rankEntries[1].val, rankEntries[2].val] };
        }
        if (countValues[0] === 2 && countValues[1] === 2) {
            return { type: HAND_TYPES.TWO_PAIR, value: rankEntries[0].val, kickers: [rankEntries[1].val, rankEntries[2].val] };
        }
        if (countValues[0] === 2) {
            return { type: HAND_TYPES.PAIR, value: rankEntries[0].val, kickers: rankEntries.slice(1).map(e => e.val) };
        }
        return { type: HAND_TYPES.HIGH_CARD, value: 0, kickers: sorted.map(c => c.value) };
    }

    static compareResults(a, b) {
        if (a.type !== b.type) return a.type - b.type;
        if (a.value !== b.value) return a.value - b.value;
        for (let i = 0; i < a.kickers.length; i++) {
            if (a.kickers[i] !== b.kickers[i]) return a.kickers[i] - b.kickers[i];
        }
        return 0;
    }
}

/**
 * AI 决策类 - 高手增强版 (基于 GTO、位置意识、胜率与赔率)
 */
class AIPolicy {
    static async decide(player, gameState) {
        // 如果有 API Key，使用大模型
        if (gameState.apiKey) {
            const seatElement = document.getElementById(`seat-${player.id}`);
            if (seatElement) seatElement.classList.add('thinking');
            
            try {
                // 创建一个 10 秒超时的 Promise
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('TIMEOUT')), 10000);
                });

                // 使用 Promise.race 竞争
                const decision = await Promise.race([
                    this.decideWithLLM(player, gameState),
                    timeoutPromise
                ]);
                
                if (seatElement) seatElement.classList.remove('thinking');
                return decision;
            } catch (error) {
                if (seatElement) seatElement.classList.remove('thinking');
                if (error.message === 'TIMEOUT') {
                    console.warn(`AI ${player.name} LLM 请求超时，切换本地策略`);
                    Game.log(`[系统] AI ${player.name} 思考超时，已切换本地策略`, 'system');
                } else {
                    console.error("LLM API Error:", error);
                    Game.log(`[系统] AI ${player.name} 接口异常: ${error.message}`, 'system');
                }
                // 降级使用内置 AI
            }
        }

        // AI 在行动前更新一下当下的“心情”
        player.updateMood();

        const cards = [...player.cards, ...gameState.communityCards];
        const handEval = cards.length >= 5 ? HandEvaluator.evaluate(cards) : null;
        const strength = handEval ? handEval.type : 0;
        
        const callAmount = gameState.currentBet - player.currentBet;
        const totalPot = gameState.pot + callAmount;
        const potOdds = callAmount / (totalPot || 1);
        
        // --- 筹码深度意识 ---
        const bb = gameState.bigBlind || 20;
        const bbCount = player.chips / bb;
        const riskRatio = callAmount / (player.chips || 1); // 跟注额占剩余筹码的比例

        // 1. 位置评估 (相对庄家的位置)
        const relativePos = (player.id - gameState.dealerIndex + 8) % 8; 
        const isLatePos = (relativePos === 0 || relativePos >= 6); // D, CO, HJ
        const isBlinds = (relativePos === 1 || relativePos === 2);

        // 2. 胜率估算 (2/4 法则 + 听牌质量)
        let equity = 0;
        let outs = 0;
        if (gameState.stage !== 'preflop' && gameState.stage !== 'showdown') {
            outs = this.calculateOuts(player.cards, gameState.communityCards);
            const multiplier = (gameState.stage === 'flop') ? 4 : 2;
            equity = (outs * multiplier) / 100;
            
            if (strength >= HAND_TYPES.THREE_OF_A_KIND) equity += 0.8;
            else if (strength >= HAND_TYPES.TWO_PAIR) equity += 0.6;
            else if (strength >= HAND_TYPES.PAIR) {
                if (this.isTopPair(player.cards, gameState.communityCards)) equity += 0.4;
                else equity += 0.15;
            }
        }

        // 3. 动态激进度：基础性格 + 激进指数 + 情绪波动
        let currentAggression = player.aggression + player.mood;
        if (player.personality === 'tight-passive') currentAggression -= 0.3;
        if (player.personality === 'loose-aggressive') currentAggression += 0.3;
        
        const rand = Math.random();

        // --- 前注圈 (Preflop) ---
        if (gameState.stage === 'preflop') {
            const power = this.evaluatePreflop(player.cards);
            
            // 计算入池意愿 (VPIP Score)
            // 考虑：手牌强度、激进度、位置、筹码深度（深筹码更谨慎）
            let vpipScore = (power / 30) + (currentAggression * 0.3) + (isLatePos ? 0.1 : 0);
            if (bbCount > 50) vpipScore -= 0.1; // 深筹码稍微收紧

            if (vpipScore > 0.85) { // 强力进攻 (AA, KK, QQ 等)
                // 减少无脑 All-in，除非筹码很少
                if (bbCount < 15) return 'raise';
                return (callAmount < player.chips * 0.3 && rand < 0.6) ? 'raise' : 'call';
            } else if (vpipScore > 0.55) { // 稳健入池
                if (riskRatio > 0.4 && currentAggression < 0.7) return 'fold'; // 成本太高则弃牌
                return (callAmount === 0 && rand < currentAggression * 0.5) ? 'raise' : 'call';
            } else if (vpipScore > 0.35) { // 边缘牌
                if (callAmount === 0) return (rand < 0.15) ? 'call' : 'fold';
                if (riskRatio < 0.1) return 'call'; // 只有在很便宜的时候才跟注
                return 'fold';
            }
            return 'fold';
        } 
        
        // --- 翻牌后 (Postflop) ---
        else {
            const isLastRaiser = gameState.lastRaiserIndex === player.id;
            
            // 计算行动激进度 (Postflop Aggression Score)
            // 考虑：牌力、胜率、情绪、位置、风险比
            let actionScore = (equity * 0.5) + (currentAggression * 0.3) + (isLatePos ? 0.1 : 0);
            if (strength >= HAND_TYPES.THREE_OF_A_KIND) actionScore += 0.4;
            if (riskRatio > 0.5) actionScore -= 0.2; // 风险太大时降低激进度

            if (actionScore > 0.95) { // 极强/极激进
                if (gameState.currentBet === 0) return 'raise';
                return (rand < 0.5) ? 'raise' : 'call';
            } else if (actionScore > 0.7) { // 强牌/半诈唬
                if (gameState.currentBet === 0) return (rand < 0.5) ? 'raise' : 'check';
                if (potOdds < equity || rand < currentAggression * 0.2) return 'call';
                return 'fold';
            } else if (actionScore > 0.4) { // 中等牌/听牌
                if (gameState.currentBet === 0) return (rand < 0.1) ? 'raise' : 'check';
                if (potOdds < equity * 1.1) return 'call';
                return 'fold';
            }

            // 空气牌但有特殊情况 (C-Bet 或 偷池)
            if (gameState.currentBet === 0) {
                if ((isLastRaiser || isLatePos) && rand < currentAggression * 0.3) return 'raise';
                return 'check';
            }

            // 极低概率的纯诈唬
            if (isLatePos && currentAggression > 0.8 && rand < 0.05) return 'raise';

            return 'fold';
        }
    }

    static async decideWithLLM(player, gameState, retryCount = 0) {
        const statusEl = document.getElementById(`status-${player.id}`);
        if (statusEl) statusEl.innerText = retryCount > 0 ? `AI 重试中(${retryCount})...` : "AI 思考中...";

        // 计算详细信息
        const cards = [...player.cards, ...gameState.communityCards];
        const handEval = cards.length >= 5 ? HandEvaluator.evaluate(cards) : (player.cards.length === 2 ? { type: -1, name: "起手牌" } : null);
        const handName = handEval ? (handEval.type === -1 ? "起手牌" : HAND_NAMES[handEval.type]) : "未知";
        
        const callAmount = gameState.currentBet - player.currentBet;
        const potOdds = callAmount > 0 ? (callAmount / (gameState.pot + callAmount)).toFixed(2) : 0;
        
        const relativePos = (player.id - gameState.dealerIndex + 8) % 8;
        const posNames = ['庄家 (Dealer)', '小盲 (Small Blind)', '大盲 (Big Blind)', '枪口位 (UTG)', '中位 1', '中位 2', '劫持位 (HJ)', '切断位 (CO)'];
        const posName = posNames[relativePos] || '中位';
        
        const activePlayers = gameState.players.filter(p => !p.isFolded).length;
        const bb = gameState.bigBlind;

        // 计算上家和下家
        const getPlayerAtOffset = (offset) => {
            let idx = (player.id + offset + 8) % 8;
            return gameState.players[idx];
        };
        const prevPlayer = getPlayerAtOffset(-1);
        const nextPlayer = getPlayerAtOffset(1);

        const systemPrompt = `你是一个顶级职业德州扑克选手（风格：激进且平衡）。你不仅关注手牌，更关注对手的行为模式。
你的目标是：在保持锦标赛生存的同时，利用激进的下注压制对手，获取最大价值。

你的行为准则：
1. 博弈意识：通过“过往动作历史”分析对手。如果有人持续表现软弱，你可以通过加注（Raise）来偷取底池；如果有人表现强劲，你需要保持警惕。
2. 激进但不盲目：你喜欢通过加注来掌握主动权，但绝不是无脑全下（All-in）。你会给游戏留出博弈空间，而不是一两局就结束战斗。
3. 风险收益比：你会根据底池赔率和对手可能的范围来决定是否继续。
4. 位置优势：在后位你会打得更加奔放，在前位则相对紧缩。
5. 拒绝冲动：每一次加注都有目的。要么是为了让更差的牌跟注（价值），要么是为了让更好的牌弃牌（诈唬）。

行动建议：
- 'fold': 赔率极差或对手表现出极强牌力时使用。
- 'check': 控制底池，或在持有强牌时设陷阱。
- 'call': 合理赔率下跟注。
- 'raise': 你的主要武器。通常加注额为 2.5x - 4x。用于施压或索取价值。
- 'allin': 仅在拥有绝对强牌（如 Nuts）、筹码量极低（<15BB）、或极高胜算的诈唬时作为杀招使用。严禁频繁全下。

请务必返回一个合法的 JSON 对象：
{
  "thought": "你的分析：结合历史动作对对手行为的研判，以及对自己位置和筹码的思考（中文，60字以内）",
  "action": "上述选项之一"
}`;

        const gameContext = {
            游戏阶段: gameState.stage,
            盲注级别: `小盲 ${gameState.smallBlind} / 大盲 ${bb}`,
            过往动作历史: gameState.actionHistory,
            我的手牌: player.cards.map(c => c.suit + c.rank).join(', '),
            公共牌: gameState.communityCards.map(c => c.suit + c.rank).join(', ') || '暂无',
            我的牌型: handName,
            我的位置: posName,
            我的座位号: player.id,
            我的剩余筹码: `${player.chips} (${(player.chips / bb).toFixed(1)} BB)`,
            
            底池信息: {
                总底池: gameState.pot,
                当前最高下注: gameState.currentBet,
                我需要跟注: callAmount,
                底池赔率: potOdds
            },

            场上动态: {
                活跃人数: activePlayers,
                我的上家: `${prevPlayer.name} (筹码: ${prevPlayer.chips}, 状态: ${prevPlayer.isFolded ? '弃牌' : '在手'})`,
                我的下家: `${nextPlayer.name} (筹码: ${nextPlayer.chips}, 状态: ${nextPlayer.isFolded ? '弃牌' : '在手'})`
            },

            玩家列表详请: gameState.players.map(p => ({
                座位: p.id,
                名称: p.name,
                筹码: `${p.chips} (${(p.chips / bb).toFixed(1)} BB)`,
                本轮投入: p.currentBet,
                状态: p.isFolded ? "弃牌" : (p.isAllIn ? "全下" : "在手"),
                角色: gameState.dealerIndex === p.id ? "庄家(D)" : ""
            }))
        };

        let apiUrl = '';
        let modelName = '';
        
        if (gameState.aiPlatform === 'siliconflow') {
            apiUrl = 'https://api.siliconflow.cn/v1/chat/completions';
        } else {
            apiUrl = 'https://api.deepseek.com/chat/completions';
        }
        modelName = gameState.aiModel; // 使用用户选择的模型

        if (!gameState.apiKey) {
            throw new Error("API Key is missing or invalid");
        }

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${gameState.apiKey.trim()}`
                },
                body: JSON.stringify({
                    model: modelName,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: `当前局面详细数据: ${JSON.stringify(gameContext, null, 2)}` }
                    ],
                    response_format: { type: 'json_object' },
                    temperature: 0.7
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const msg = errorData.error?.message || `HTTP ${response.status}`;
                throw new Error(msg);
            }

            const data = await response.json();
            const result = JSON.parse(data.choices[0].message.content);
            
            if (!result.action) throw new Error("Invalid response format: missing action");

            return result.action;
        } catch (error) {
            console.error(`AI API Attempt ${retryCount + 1} Error:`, error);
            if (retryCount < 1) { // 失败时重试一次
                return await this.decideWithLLM(player, gameState, retryCount + 1);
            }
            throw error; 
        }
    }

    // 计算补牌 (Outs) - 更精准
    static calculateOuts(holeCards, communityCards) {
        let outs = 0;
        const allCards = [...holeCards, ...communityCards];
        
        // 1. 同花听牌 (9 outs)
        const suits = {};
        allCards.forEach(c => suits[c.suit] = (suits[c.suit] || 0) + 1);
        let flushSuit = null;
        for (const [suit, count] of Object.entries(suits)) {
            if (count === 4) { flushSuit = suit; outs += 9; break; }
        }

        // 2. 顺子听牌
        const values = Array.from(new Set(allCards.map(c => c.value))).sort((a,b) => a-b);
        // 检查 A2345 顺子听牌
        const hasAce = values.includes(14);
        const lowValues = hasAce ? [1, ...values.filter(v => v < 14)] : values;
        
        let maxConnect = 0;
        for (let i = 0; i < values.length; i++) {
            let count = 1;
            for (let j = i + 1; j < values.length; j++) {
                if (values[j] === values[i] + (j - i)) count++;
                else break;
            }
            maxConnect = Math.max(maxConnect, count);
        }
        
        if (maxConnect === 4) {
            // 两头顺 (8 outs) 或 只有一头 (4 outs)
            // 简单处理：两头顺 8，卡顺 4
            const isOESD = this.isOESD(values);
            outs += isOESD ? 8 : 4;
        }

        // 3. 超额牌 (Overcards) - 翻牌到转牌时
        const communityMax = Math.max(...communityCards.map(c => c.value));
        holeCards.forEach(c => {
            if (c.value > communityMax) outs += 3; // 每一张超额牌约 3 outs
        });

        return Math.min(outs, 18);
    }

    // AI 心理活动描述
    static getThought(player, action) {
        const personalityMap = {
            'tight-passive': {
                'fold': ['牌太烂了，还是稳着点...', '这种赔率不值得冒险。', '等一手大牌再进。'],
                'call': ['跟注看看翻牌，希望运气好点。', '这个价格可以接受。'],
                'check': ['先看看情况...', '希望能免费看下一张。'],
                'raise': ['这把牌稳了！', '稍微加一点试试水。']
            },
            'loose-aggressive': {
                'fold': ['啧，这把没戏。', '换一局再收拾你们。'],
                'call': ['你以为你能吓走我？', '我也想看看你的牌。'],
                'check': ['让你先出招。', '过牌，等会再加注。'],
                'raise': ['直接拉满压力！', '这就是我的风格！', '诈唬？也许吧。']
            },
            'balanced': {
                'fold': ['概率上不支持跟注。', '放弃是明智的选择。'],
                'call': ['合理的跟注。', '按计划行事。'],
                'check': ['标准过牌。', '控制底池。'],
                'raise': ['价值下注。', '平衡我的范围。']
            }
        };

        const thoughts = personalityMap[player.personality] || personalityMap['balanced'];
        const list = thoughts[action] || ['思考中...'];
        return list[Math.floor(Math.random() * list.length)];
    }

    static isOESD(values) {
        // 简单判断是否为两头顺
        for (let i = 0; i <= values.length - 4; i++) {
            if (values[i+3] === values[i] + 3) {
                // 如果不是 A-high 或 5-high (避免一头顺)
                if (values[i] > 1 && values[i+3] < 14) return true;
            }
        }
        return false;
    }

    static isTopPair(holeCards, communityCards) {
        if (communityCards.length === 0) return false;
        const communityMax = Math.max(...communityCards.map(c => c.value));
        return holeCards.some(c => c.value === communityMax);
    }

    // 前注圈手牌强度评估 (1-30+)
    static evaluatePreflop(cards) {
        const v1 = cards[0].value;
        const v2 = cards[1].value;
        const isPair = v1 === v2;
        const isSuited = cards[0].suit === cards[1].suit;
        const high = Math.max(v1, v2);
        const low = Math.min(v1, v2);
        const gap = high - low;
        
        let score = high;
        if (isPair) score += 15; // 对子大幅加分
        if (isSuited) score += 4; // 同花加分
        if (gap === 1) score += 2; // 连张
        if (gap === 2) score += 1; // 隔张
        
        // 惩罚弱踢脚 A
        if (high === 14 && low < 8 && !isSuited && !isPair) score -= 2;
        
        return score;
    }
}


/**
 * 游戏主逻辑
 */
const Game = {
    init() {
        this.bindEvents();
    },

    bindEvents() {
        document.getElementById('start-game-btn').onclick = () => this.startGame();
        document.getElementById('restart-game-btn').onclick = () => {
            document.getElementById('result-modal').classList.add('hidden');
            document.getElementById('setup-modal').classList.remove('hidden');
        };

        // 清除缓存并刷新
        document.getElementById('btn-clear-cache').onclick = async () => {
            if ('serviceWorker' in navigator) {
                const registrations = await navigator.serviceWorker.getRegistrations();
                for (let registration of registrations) {
                    await registration.unregister();
                }
            }
            if ('caches' in window) {
                const keys = await caches.keys();
                for (let key of keys) {
                    await caches.delete(key);
                }
            }
            window.location.reload(true);
        };

        // 监听平台和 API Key 输入，启用/禁用模型选择并更新选项
        const aiPlatformSelect = document.getElementById('ai-platform');
        const apiKeyInput = document.getElementById('api-key');
        const aiModelSelect = document.getElementById('ai-model');
        const defaultKey = "sk-yomwzgtkkyluoafqpevyolskpgcwgipehqoqggmfedmoxfou";
        
        const siliconFlowModels = [
            { value: "Qwen/Qwen2.5-7B-Instruct", text: "Qwen/Qwen2.5-7B-Instruct (默认)" },
            { value: "deepseek-ai/DeepSeek-V3", text: "deepseek-ai/DeepSeek-V3" },
            { value: "moonshotai/Kimi-K1.5-Chat", text: "moonshotai/Kimi-K1.5-Chat" },
            { value: "Qwen/Qwen2.5-Coder-32B-Instruct", text: "Qwen/Qwen2.5-Coder-32B-Instruct" }
        ];

        const deepseekModels = [
            { value: "deepseek-chat", text: "DeepSeek-V3.2 (非思考模式)" },
            { value: "deepseek-reasoner", text: "DeepSeek-V3.2 (思考模式)" }
        ];

        const updateModelSelect = () => {
            const platform = aiPlatformSelect.value;
            const currentKey = apiKeyInput.value.trim();
            const isDefault = currentKey === defaultKey;
            
            // 清空并重新填充模型选项
            const currentModel = aiModelSelect.value;
            aiModelSelect.innerHTML = '';
            
            const models = platform === 'siliconflow' ? siliconFlowModels : deepseekModels;
            models.forEach(m => {
                const opt = document.createElement('option');
                opt.value = m.value;
                opt.text = m.text;
                aiModelSelect.appendChild(opt);
            });

            if (isDefault || !currentKey) {
                // 如果是默认 key 或为空，强制选择默认模型并禁用切换
                if (platform === 'siliconflow') {
                    aiModelSelect.value = "Qwen/Qwen2.5-7B-Instruct";
                } else {
                    aiModelSelect.value = "deepseek-chat";
                }
                aiModelSelect.disabled = true;
            } else {
                // 只有输入了自己的 key，才允许切换模型
                aiModelSelect.disabled = false;
                // 尝试恢复之前选中的模型，如果不在列表中则选第一个
                if (models.some(m => m.value === currentModel)) {
                    aiModelSelect.value = currentModel;
                }
            }
        };
        
        aiPlatformSelect.onchange = updateModelSelect;
        apiKeyInput.oninput = updateModelSelect;
        // 初始检查
        updateModelSelect();

        // 玩家行动按钮
        document.getElementById('btn-fold').onclick = () => this.handlePlayerAction('fold');
        document.getElementById('btn-check').onclick = () => this.handlePlayerAction('check');
        document.getElementById('btn-call').onclick = () => this.handlePlayerAction('call');
        document.getElementById('btn-allin').onclick = () => this.handlePlayerAction('allin');
        document.getElementById('btn-raise').onclick = () => {
            const amount = parseInt(document.getElementById('raise-amount-input').value);
            this.handlePlayerAction('raise', amount);
        };

        // 手机端日志切换
        const logContainer = document.getElementById('game-log-container');
        const logBody = document.getElementById('game-log-body');
        document.getElementById('btn-log').onclick = () => {
            logContainer.classList.add('active-mobile');
            // 延迟一点点确保渲染后再滚动
            setTimeout(() => {
                logBody.scrollTop = logBody.scrollHeight;
            }, 50);
        };
        document.getElementById('close-log').onclick = (e) => {
            e.stopPropagation();
            logContainer.classList.remove('active-mobile');
        };

        const slider = document.getElementById('raise-slider');
        const input = document.getElementById('raise-amount-input');

        slider.oninput = (e) => {
            input.value = e.target.value;
        };

        input.oninput = (e) => {
            let val = parseInt(e.target.value) || 0;
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            
            // 只有当输入值在有效范围内时才同步滑动条
            // 但允许用户输入过程中的中间状态
            if (val >= min && val <= max) {
                slider.value = val;
            }
        };

        input.onblur = (e) => {
            let val = parseInt(e.target.value) || 0;
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            
            // 失去焦点时强制修正到有效范围
            if (val < min) val = min;
            if (val > max) val = max;
            
            input.value = val;
            slider.value = val;
        };
    },

    startGame() {
        const playerName = document.getElementById('player-name').value || '你';
        const startChips = parseInt(document.getElementById('start-chips').value) || 10000;
        const smallBlind = parseInt(document.getElementById('small-blind').value) || 50;
        // 清洗 API Key，移除任何可能的非 ASCII 字符或隐藏字符
        const apiKey = document.getElementById('api-key').value.replace(/[^\x00-\x7F]/g, "").trim();
        const aiPlatform = document.getElementById('ai-platform').value;
        const aiModel = document.getElementById('ai-model').value;

        gameState.players = [
            new Player(0, playerName, startChips, false),
            new Player(1, "AI 1", startChips, true),
            new Player(2, "AI 2", startChips, true),
            new Player(3, "AI 3", startChips, true),
            new Player(4, "AI 4", startChips, true),
            new Player(5, "AI 5", startChips, true),
            new Player(6, "AI 6", startChips, true),
            new Player(7, "AI 7", startChips, true)
        ];
        gameState.smallBlind = smallBlind;
        gameState.bigBlind = smallBlind * 2;
        gameState.dealerIndex = Math.floor(Math.random() * 8);
        gameState.apiKey = apiKey;
        gameState.aiPlatform = aiPlatform;
        gameState.aiModel = aiModel;

        document.getElementById('setup-modal').classList.add('hidden');
        document.getElementById('controls').classList.remove('hidden');
        
        // 确保 UI 已经根据 players 进行了第一次渲染
        this.updateUI();
        
        this.log('游戏开始！', 'system');
        this.startNewHand();
    },

    startNewHand() {
        // 重置状态
        gameState.handCount++;
        document.getElementById('hand-number').innerText = `局数: ${gameState.handCount}`;
        this.log(`--- 第 ${gameState.handCount} 局开始 ---`, 'system');

        gameState.deck = this.createDeck();
        this.shuffle(gameState.deck);
        gameState.communityCards = [];
        gameState.pot = 0;
        gameState.stage = 'preflop';
        gameState.currentBet = gameState.bigBlind;
        gameState.minRaise = gameState.bigBlind;
        gameState.lastRaiserIndex = -1;
        gameState.actionHistory = []; // 重置动作历史

        gameState.players.forEach(p => {
            p.cards = [];
            p.currentBet = 0;
            p.totalContributed = 0; // 重置本局投入
            p.isFolded = p.chips <= 0;
            p.isAllIn = false;
            p.hasActed = false;
            p.handResult = null;
            
            // 每一局开始，AI 都会刷新自己的性格和状态，增加多变性
            if (p.isAI && p.chips > 0) {
                p.refreshPersonality();
            }
        });

        // 移动庄家位
        let dIdx = (gameState.dealerIndex + 1) % 8;
        while (gameState.players[dIdx].chips <= 0) {
            dIdx = (dIdx + 1) % 8;
        }
        gameState.dealerIndex = dIdx;

        // 查找小盲位 (庄家左手边第一个有筹码的玩家)
        let sbIndex = (gameState.dealerIndex + 1) % 8;
        while (gameState.players[sbIndex].chips <= 0) {
            sbIndex = (sbIndex + 1) % 8;
        }
        
        // 查找大盲位 (小盲左手边第一个有筹码的玩家)
        let bbIndex = (sbIndex + 1) % 8;
        while (gameState.players[bbIndex].chips <= 0) {
            bbIndex = (bbIndex + 1) % 8;
        }
        
        this.playerBet(gameState.players[sbIndex], gameState.smallBlind);
        this.log(`${gameState.players[sbIndex].name} 支付小盲注: ${gameState.smallBlind}`, 'action');
        this.recordAction(gameState.players[sbIndex], 'sb', gameState.smallBlind);
        this.playerBet(gameState.players[bbIndex], gameState.bigBlind);
        this.log(`${gameState.players[bbIndex].name} 支付大盲注: ${gameState.bigBlind}`, 'action');
        this.recordAction(gameState.players[bbIndex], 'bb', gameState.bigBlind);

        // 发牌
        gameState.players.forEach(p => {
            if (!p.isFolded) {
                p.cards.push(gameState.deck.pop(), gameState.deck.pop());
            }
        });

        gameState.currentPlayerIndex = (bbIndex + 1) % 8;
        this.updateUI();
        this.processTurn();
    },

    createDeck() {
        const deck = [];
        for (const suit of SUITS) {
            for (const rank of RANKS) {
                deck.push(new Card(suit, rank));
            }
        }
        return deck;
    },

    shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    },

    playerBet(player, amount) {
        const actualAmount = Math.min(player.chips, amount);
        const oldBet = player.currentBet;
        player.chips -= actualAmount;
        player.currentBet += actualAmount;
        player.totalContributed += actualAmount;
        gameState.pot += actualAmount;
        if (player.chips === 0) player.isAllIn = true;
        
        const raiseAmount = player.currentBet - gameState.currentBet;
        if (raiseAmount > 0) {
            // 只有当加注额超过或等于当前的最小加注额时，才更新最小加注额并重置其他人的行动状态
            // 或者这是本轮的第一次加注（针对大盲注的情况）
            if (raiseAmount >= gameState.minRaise) {
                gameState.minRaise = raiseAmount;
                gameState.currentBet = player.currentBet;
                gameState.lastRaiserIndex = player.id;
                // 重置其他人的行动状态
                gameState.players.forEach(p => {
                    if (p.id !== player.id && !p.isFolded && !p.isAllIn) {
                        p.hasActed = false;
                    }
                });
            } else {
                // 如果是不足额的 All-in 加注，虽然更新了 currentBet，但不重置其他人的 hasActed
                // 且不更新 minRaise
                gameState.currentBet = player.currentBet;
            }
        }
        player.hasActed = true;
    },

    async processTurn() {
        const activePlayers = gameState.players.filter(p => !p.isFolded && !p.isAllIn);
        
        // 检查这一轮是否结束
        const roundFinished = gameState.players.every(p => 
            p.isFolded || p.isAllIn || (p.hasActed && p.currentBet === gameState.currentBet)
        );

        if (roundFinished) {
            await this.nextStage();
            return;
        }

        const current = gameState.players[gameState.currentPlayerIndex];
        if (current.isFolded || current.isAllIn) {
            this.moveToNextPlayer();
            this.processTurn();
            return;
        }

        this.updateUI();

        if (current.isAI) {
            this.enableControls(false);
            // 在 UI 上显示“思考中...”
            const statusEl = document.getElementById(`status-${current.id}`);
            if (statusEl) statusEl.innerText = "思考中...";
            
            // 随机思考时间，模拟 AI 在“思考”
            const thinkTime = 800 + Math.random() * 2000;
            await new Promise(r => setTimeout(r, thinkTime)); 
            
            const action = await AIPolicy.decide(current, gameState);
            // 隐藏本地 AI 的思考细节
            // const thought = AIPolicy.getThought(current, action);
            
            // 有概率在日志中输出 AI 的“心理活动” - 已隐藏
            /*
            if (Math.random() < 0.4) {
                this.log(`${current.name}: "${thought}"`, 'thought');
            }
            */
            
            this.handleAIAction(current, action);
        } else {
            this.showMessage("轮到你行动");
            this.enableControls(true);
        }
    },

    handleAIAction(player, action) {
        const callAmount = gameState.currentBet - player.currentBet;
        
        if (action === 'fold' && callAmount > 0) {
            player.isFolded = true;
            this.log(`${player.name} 弃牌`, 'action');
            this.recordAction(player, 'fold');
            this.showMessage(`${player.name} 弃牌`);
        } else if (action === 'raise') {
            const minRaiseAmt = gameState.currentBet + gameState.minRaise;
            const potSize = gameState.pot;
            const rand = Math.random();
            let targetBet = minRaiseAmt;
            
            // 更加多样化的下注尺度
            if (gameState.stage === 'preflop') {
                // 翻牌前：通常是 3x 盲注或 3x 上一次加注
                targetBet = gameState.currentBet === gameState.bigBlind ? 
                    gameState.bigBlind * 3 : gameState.currentBet * 2.5;
            } else {
                // 翻牌后：根据底池大小下注
                if (rand < 0.25) {
                    targetBet = gameState.currentBet + Math.floor(potSize * 0.33); // 1/3 池 (试探/干燥面)
                } else if (rand < 0.6) {
                    targetBet = gameState.currentBet + Math.floor(potSize * 0.5);  // 1/2 池 (标准)
                } else if (rand < 0.9) {
                    targetBet = gameState.currentBet + Math.floor(potSize * 0.75); // 3/4 池 (价值/保护)
                } else {
                    targetBet = gameState.currentBet + potSize; // 满池 (强力挤压)
                }
            }
            
            // 确保加注额合法
            targetBet = Math.max(minRaiseAmt, Math.floor(targetBet));
            targetBet = Math.min(targetBet, player.chips + player.currentBet);
            
            const actualBetNeeded = targetBet - player.currentBet;
            this.playerBet(player, actualBetNeeded);
            
            const isAllIn = player.isAllIn;
            this.log(`${player.name} ${isAllIn ? '全下' : '加注'} 到 ${player.currentBet}`, 'action');
            this.recordAction(player, isAllIn ? 'allin' : 'raise');
            this.showMessage(`${player.name} ${isAllIn ? '全下!' : '加注'}`);
        } else if (action === 'call' || (action === 'check' && callAmount === 0)) {
            const isCall = callAmount > 0;
            this.playerBet(player, callAmount);
            const msg = isCall ? `${player.name} 跟注 ${callAmount}` : `${player.name} 过牌`;
            this.log(msg, 'action');
            this.recordAction(player, isCall ? 'call' : 'check', callAmount);
            this.showMessage(isCall ? `${player.name} 跟注` : `${player.name} 过牌`);
        } else {
            // 后备逻辑
            if (callAmount === 0) {
                this.playerBet(player, 0);
                this.log(`${player.name} 过牌`, 'action');
                this.recordAction(player, 'check');
                this.showMessage(`${player.name} 过牌`);
            } else if (player.chips <= callAmount) {
                const totalBet = player.chips + player.currentBet;
                this.playerBet(player, player.chips);
                this.log(`${player.name} 全下!`, 'action');
                this.recordAction(player, 'allin');
                this.showMessage(`${player.name} 全下`);
            } else {
                player.isFolded = true;
                this.log(`${player.name} 弃牌`, 'action');
                this.recordAction(player, 'fold');
                this.showMessage(`${player.name} 弃牌`);
            }
        }

        this.moveToNextPlayer();
        this.processTurn();
    },

    handlePlayerAction(action, amount = 0) {
        const player = gameState.players[0];
        const callAmount = gameState.currentBet - player.currentBet;

        if (action === 'fold') {
            player.isFolded = true;
            this.log(`你 弃牌`, 'action');
            this.recordAction(player, 'fold');
        } else if (action === 'check') {
            this.playerBet(player, 0);
            this.log(`你 过牌`, 'action');
            this.recordAction(player, 'check');
        } else if (action === 'call') {
            this.playerBet(player, callAmount);
            this.log(`你 跟注 ${callAmount}`, 'action');
            this.recordAction(player, 'call', callAmount);
        } else if (action === 'allin') {
            this.playerBet(player, player.chips);
            this.log(`你 全下!`, 'action');
            this.recordAction(player, 'allin');
        } else if (action === 'raise') {
            const actualRaise = amount - player.currentBet;
            this.playerBet(player, actualRaise);
            this.log(`你 加注到 ${player.currentBet}`, 'action');
            this.recordAction(player, player.isAllIn ? 'allin' : 'raise');
        }

        this.enableControls(false);
        this.moveToNextPlayer();
        this.processTurn();
    },

    moveToNextPlayer() {
        gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % 8;
    },

    async nextStage() {
        // 重置本轮下注
        gameState.players.forEach(p => {
            p.currentBet = 0;
            p.hasActed = false;
        });
        gameState.currentBet = 0;
        gameState.minRaise = gameState.bigBlind;

        const notFolded = gameState.players.filter(p => !p.isFolded);
        if (notFolded.length === 1) {
            this.resolveWinner(notFolded[0]);
            return;
        }

        if (gameState.stage === 'preflop') {
            gameState.stage = 'flop';
            gameState.communityCards.push(gameState.deck.pop(), gameState.deck.pop(), gameState.deck.pop());
            this.log(`--- 翻牌圈 (Flop) ---`, 'system');
        } else if (gameState.stage === 'flop') {
            gameState.stage = 'turn';
            gameState.communityCards.push(gameState.deck.pop());
            this.log(`--- 转牌圈 (Turn) ---`, 'system');
        } else if (gameState.stage === 'turn') {
            gameState.stage = 'river';
            gameState.communityCards.push(gameState.deck.pop());
            this.log(`--- 河牌圈 (River) ---`, 'system');
        } else if (gameState.stage === 'river') {
            this.log(`--- 摊牌 (Showdown) ---`, 'system');
            this.showdown();
            return;
        }

        // 检查是否所有人都全下了（或者只有一人没全下/弃牌）
        const canBet = gameState.players.filter(p => !p.isFolded && !p.isAllIn);
        if (canBet.length <= 1 && notFolded.length > 1) {
            this.updateUI();
            // 所有人全下时，发牌节奏加快
            await new Promise(r => setTimeout(r, 800));
            this.nextStage();
            return;
        }

        // 正常流程：从庄家左手边第一个未弃牌的玩家开始
        let nextPlayerIdx = (gameState.dealerIndex + 1) % 8;
        while (gameState.players[nextPlayerIdx].isFolded || gameState.players[nextPlayerIdx].isAllIn) {
            nextPlayerIdx = (nextPlayerIdx + 1) % 8;
        }
        gameState.currentPlayerIndex = nextPlayerIdx;
        this.updateUI();
        this.processTurn();
    },

    showdown() {
        gameState.stage = 'showdown';
        this.showMessage("正在摊牌结算...", 3000);
        const activePlayers = gameState.players.filter(p => !p.isFolded);
        
        activePlayers.forEach(p => {
            p.handResult = HandEvaluator.evaluate([...p.cards, ...gameState.communityCards]);
        });

        // 复杂的边池计算逻辑
        const winnersInfo = this.calculatePots(activePlayers);
        
        this.updateUI();
        
        winnersInfo.forEach(info => {
            this.log(`${info.player.name} 赢得了 ${info.amount} (${HAND_NAMES[info.player.handResult.type]})`, 'win');
        });

        // 记录其他人的损益
        gameState.players.forEach(p => {
            if (p.totalContributed > 0) {
                const winInfo = winnersInfo.find(wi => wi.player.id === p.id);
                const net = (winInfo ? winInfo.amount : 0) - p.totalContributed;
                if (net < 0) {
                    this.log(`${p.name} 输掉了 ${Math.abs(net)}`, 'loss');
                }
            }
        });
        
        let resultMsg = winnersInfo.map(info => 
            `${info.player.name} (${HAND_NAMES[info.player.handResult.type]}) 赢得了 ${info.amount}`
        ).join('\n');
        
        // 缩短一点等待时间，让节奏更紧凑
        setTimeout(() => {
            this.checkGameEnd(resultMsg);
        }, 3000);
    },

    // 边池计算核心算法 (修复版：支持多重边池与平分)
    calculatePots(activePlayers) {
        let remainingPot = gameState.pot;
        const results = [];
        
        // 复制所有玩家的投入数据，用于逐层扣除
        const contributions = gameState.players.map(p => ({ 
            id: p.id, 
            amount: p.totalContributed,
            player: p
        }));

        // 获取所有不同的投入梯度（去重并升序排列），用于划分底池层级
        const levels = [...new Set(contributions.map(c => c.amount))]
            .filter(a => a > 0)
            .sort((a, b) => a - b);

        let prevLevel = 0;
        
        // 逐层处理底池
        for (const level of levels) {
            const currentLevelHeight = level - prevLevel;
            let currentLevelPot = 0;
            
            // 谁参与了这一层的底池？
            const eligiblePlayers = contributions.filter(c => c.amount > 0);
            eligiblePlayers.forEach(c => {
                const take = Math.min(c.amount, currentLevelHeight);
                currentLevelPot += take;
                c.amount -= take;
            });

            if (currentLevelPot <= 0) continue;

            // 在参与了这一层底池的玩家中，谁没弃牌？
            const activeEligible = eligiblePlayers
                .filter(c => !c.player.isFolded)
                .map(c => c.player);

            if (activeEligible.length > 0) {
                // 找出这一层中牌力最强的玩家
                let bestResult = null;
                activeEligible.forEach(p => {
                    if (!bestResult || HandEvaluator.compareResults(p.handResult, bestResult) > 0) {
                        bestResult = p.handResult;
                    }
                });

                const winners = activeEligible.filter(p => 
                    HandEvaluator.compareResults(p.handResult, bestResult) === 0
                );

                // 分配这一层的钱
                const share = Math.floor(currentLevelPot / winners.length);
                const remainder = currentLevelPot % winners.length;

                winners.forEach(w => {
                    w.chips += share;
                    // 记录结果（如果是同一个人在不同层赢了，合并显示）
                    const existing = results.find(r => r.player.id === w.id);
                    if (existing) {
                        existing.amount += share;
                    } else {
                        results.push({ player: w, amount: share });
                    }
                });

                // 处理除不尽的余数：按位置分配（给庄家左手边最近的赢家）
                if (remainder > 0) {
                    // 计算每个赢家相对于庄家的位置
                    const sortedWinners = winners.sort((a, b) => {
                        const posA = (a.id - gameState.dealerIndex + 8) % 8;
                        const posB = (b.id - gameState.dealerIndex + 8) % 8;
                        return posA - posB;
                    });
                    sortedWinners[0].chips += remainder;
                    const existing = results.find(r => r.player.id === sortedWinners[0].id);
                    if (existing) existing.amount += remainder;
                }
            } else {
                // 如果这一层没有任何没弃牌的玩家（极端情况，如所有人都在后续圈弃牌），退还给最后投入的人
                // 这种情况在正常流程中几乎不会发生，因为至少会有一个人留到最后
            }

            prevLevel = level;
        }

        return results;
    },

    resolveWinner(winner) {
        const net = gameState.pot - winner.totalContributed;
        winner.chips += gameState.pot;
        this.updateUI();
        this.log(`${winner.name} 赢得了底池 ${gameState.pot} (其他玩家弃牌)`, 'win');
        
        // 记录其他人的损益
        gameState.players.forEach(p => {
            if (p.id !== winner.id && p.totalContributed > 0) {
                this.log(`${p.name} 输掉了 ${p.totalContributed}`, 'loss');
            }
        });

        this.showMessage(`${winner.name} 赢得了底池 ${gameState.pot} (其他玩家弃牌)`);
        setTimeout(() => {
            this.checkGameEnd(`${winner.name} 赢得了底池`);
        }, 2000);
    },

    checkGameEnd(lastHandMsg) {
        const alivePlayers = gameState.players.filter(p => p.chips > 0);
        if (alivePlayers.length === 1) {
            const modal = document.getElementById('result-modal');
            const title = document.getElementById('result-title');
            const body = document.getElementById('result-body');
            
            modal.classList.remove('hidden');
            title.innerText = alivePlayers[0].id === 0 ? "恭喜你赢了！" : "游戏结束";
            body.innerText = `${alivePlayers[0].name} 赢得了所有筹码！\n\n${lastHandMsg}`;
        } else if (gameState.players[0].chips <= 0) {
            const modal = document.getElementById('result-modal');
            const title = document.getElementById('result-title');
            const body = document.getElementById('result-body');
            
            modal.classList.remove('hidden');
            title.innerText = "你输了";
            body.innerText = `你的筹码已输光。\n\n${lastHandMsg}`;
        } else {
            this.startNewHand();
        }
    },

    updateUI() {
        // 更新公共牌
        const commContainer = document.getElementById('community-cards');
        commContainer.innerHTML = '';
        gameState.communityCards.forEach(card => {
            commContainer.appendChild(this.createCardUI(card));
        });

        // 更新底池
        document.getElementById('main-pot').innerText = gameState.pot;

        // 更新玩家信息
        gameState.players.forEach((p, i) => {
            const seat = document.getElementById(`seat-${i}`);
            const nameEl = document.getElementById(`name-${i}`);
            const chipsEl = document.getElementById(`chips-${i}`);
            const statusEl = document.getElementById(`status-${i}`);
            const cardsEl = document.getElementById(`cards-${i}`);
            const betEl = document.getElementById(`bet-${i}`);

            nameEl.innerText = p.name;
            chipsEl.innerText = p.chips;
            seat.className = `player-seat ${this.getSeatClass(i)} ${gameState.currentPlayerIndex === i ? 'active' : ''}`;
            
            let statusText = "";
            if (p.isFolded) {
                statusText = "弃牌";
                seat.style.opacity = "0.5";
            } else {
                seat.style.opacity = "1";
                if (p.isAllIn) statusText = "全下";
                else if (gameState.dealerIndex === i) statusText = "庄家 (D)";
            }
            statusEl.innerText = statusText;

            // 渲染手牌
            cardsEl.innerHTML = '';
            if (!p.isFolded && p.cards.length > 0) {
                p.cards.forEach(card => {
                    // 只有玩家自己的牌或摊牌阶段才显示
                    const hidden = (p.isAI && gameState.stage !== 'showdown');
                    cardsEl.appendChild(this.createCardUI(card, hidden));
                });
            }

            // 渲染下注筹码
            betEl.innerHTML = '';
            if (p.currentBet > 0) {
                betEl.innerHTML = `<span class="chip-label">${p.currentBet}</span>`;
                const chipCount = Math.min(5, Math.ceil(p.currentBet / 100));
                for(let c=0; c<chipCount; c++) {
                    const chip = document.createElement('div');
                    chip.className = 'chip';
                    chip.style.backgroundColor = this.getChipColor(p.currentBet);
                    betEl.appendChild(chip);
                }
            }
        });

        // 更新操作面板
        if (gameState.currentPlayerIndex === 0) {
            const p = gameState.players[0];
            const callAmt = gameState.currentBet - p.currentBet;
            
            document.getElementById('btn-check').classList.toggle('hidden', callAmt > 0);
            document.getElementById('btn-call').classList.toggle('hidden', callAmt === 0 || p.chips <= callAmt);
            document.getElementById('call-amount').innerText = callAmt;
            
            const minRaise = gameState.currentBet + gameState.minRaise;
            const canRaise = p.chips > callAmt + gameState.minRaise;
            
            document.getElementById('raise-slider-container').classList.toggle('hidden', !canRaise);
            document.getElementById('btn-raise').classList.toggle('hidden', !canRaise);
            
            if (canRaise) {
                const slider = document.getElementById('raise-slider');
                slider.min = minRaise;
                slider.max = p.chips + p.currentBet;
                slider.value = minRaise;
                document.getElementById('raise-amount-input').value = minRaise;
            }
        }
    },

    createCardUI(card, hidden = false) {
        const el = document.createElement('div');
        el.className = `card ${hidden ? 'hidden' : card.color}`;
        if (!hidden) {
            el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
        }
        return el;
    },

    getSeatClass(i) {
        const seats = [
            'bottom',       // 玩家 (0)
            'bottom-left',  // AI 1
            'left',         // AI 2
            'top-left',     // AI 3
            'top',          // AI 4
            'top-right',    // AI 5
            'right',        // AI 6
            'bottom-right'  // AI 7
        ];
        return seats[i] || 'bottom';
    },

    getChipColor(amt) {
        if (amt >= 1000) return '#d32f2f'; // 红
        if (amt >= 500) return '#1976d2';  // 蓝
        if (amt >= 100) return '#388e3c';  // 绿
        return '#fbc02d'; // 黄
    },

    enableControls(enabled) {
        const btns = document.querySelectorAll('#controls button:not(#btn-log)');
        btns.forEach(b => b.disabled = !enabled);
        const inputs = document.querySelectorAll('#controls input');
        inputs.forEach(i => i.disabled = !enabled);
    },

    showMessage(text) {
        const msg = document.getElementById('game-msg');
        msg.innerText = text;
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), 2000);
    },

    recordAction(player, action, amount = 0) {
        const stageNames = {
            'preflop': '翻牌前',
            'flop': '翻牌圈',
            'turn': '转牌圈',
            'river': '河牌圈'
        };
        let actionDesc = '';
        switch(action) {
            case 'fold': actionDesc = '弃牌'; break;
            case 'check': actionDesc = '过牌'; break;
            case 'call': actionDesc = `跟注 ${amount}`; break;
            case 'raise': actionDesc = `加注到 ${player.currentBet}`; break;
            case 'allin': actionDesc = `全下 ${player.currentBet}`; break;
            case 'sb': actionDesc = `支付小盲 ${amount}`; break;
            case 'bb': actionDesc = `支付大盲 ${amount}`; break;
            default: actionDesc = action;
        }
        const stage = stageNames[gameState.stage] || '结算';
        const entry = `[${stage}] ${player.name}: ${actionDesc}`;
        gameState.actionHistory.push(entry);
    },

    log(text, type = 'action') {
        const logBody = document.getElementById('game-log-body');
        if (!logBody) return; // 移动端可能隐藏
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.innerText = text;
        logBody.appendChild(entry);
        logBody.scrollTop = logBody.scrollHeight;
    }
};

// 初始化游戏
    Game.init();

    // 注册 Service Worker (PWA)
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('SW registered'))
                .catch(err => console.log('SW registration failed', err));
        });
    }
</script>

</body>
</html>
