<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>单机德州王</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a1a">
    <link rel="apple-touch-icon" href="https://img.icons8.com/emoji/96/spade-suit.png">
    <link rel="icon" type="image/png" href="https://img.icons8.com/emoji/32/spade-suit.png">
    <style>
        :root {
            --table-green: radial-gradient(circle, #2e7d32 0%, #1b5e20 100%);
            --felt-color: #245a27;
            --border-wood: #5d4037;
            --card-white: #ffffff;
            --card-back: #c62828;
            --player-bg: rgba(0, 0, 0, 0.6);
            --highlight-color: #ffeb3b;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: "Microsoft YaHei", sans-serif; }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
        }

        body {
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 主布局 */
        #main-layout {
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background: #1a1a1a;
        }

        /* 游戏容器 */
        #game-container {
            position: relative;
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            align-items: center;
            padding: 10px;
            min-width: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #2a2a2a 0%, #1a1a1a 100%);
        }

        /* 牌桌区域 */
        #poker-table {
            position: relative;
            width: 95%;
            max-width: 900px;
            max-height: 65vh;
            aspect-ratio: 16 / 9;
            background: var(--table-green);
            border: 15px solid var(--border-wood);
            border-radius: 200px;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5), 0 10px 20px rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 1;
        }

        /* 公共牌区 */
        #community-cards {
            display: flex;
            gap: 10px;
            perspective: 1000px;
        }

        /* 锅底/池 */
        #pot-container {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            background: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 1.1rem;
            color: #ffd700;
            font-weight: bold;
            z-index: 30;
            border: 1px solid rgba(255,215,0,0.3);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        /* 玩家位置 */
        .player-seat {
            position: absolute;
            width: 120px;
            text-align: center;
            z-index: 5;
        }

        .player-seat.active {
            filter: drop-shadow(0 0 10px var(--highlight-color));
        }

        .player-seat.bottom { bottom: -10px; left: 50%; transform: translateX(-50%); }
        .player-seat.left   { left: 20px; top: 50%; transform: translateY(-50%); }
        .player-seat.top    { top: -10px; left: 50%; transform: translateX(-50%); }
        .player-seat.right  { right: 20px; top: 50%; transform: translateY(-50%); }

        .player-info {
            background: var(--player-bg);
            padding: 8px;
            border-radius: 10px;
            border: 2px solid #444;
            margin-bottom: 5px;
        }
        .player-seat.active .player-info { border-color: var(--highlight-color); }

        .player-name { font-size: 0.9rem; margin-bottom: 2px; }
        .player-chips { color: #ffd700; font-weight: bold; font-size: 1rem; }
        .player-status { font-size: 0.8rem; color: #aaa; height: 1.2em; }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            height: 60px;
        }

        /* 卡牌样式 */
        .card {
            width: 45px;
            height: 65px;
            background: white;
            border-radius: 5px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 3px;
            color: black;
            font-weight: bold;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            user-select: none;
        }

        .card.red { color: #d32f2f; }
        .card.black { color: #000; }
        .card.hidden {
            background: var(--card-back);
            background-image: radial-gradient(circle, #fff 10%, transparent 10%), radial-gradient(circle, #fff 10%, transparent 10%);
            background-size: 10px 10px;
            background-position: 0 0, 5px 5px;
        }
        .card.hidden * { visibility: hidden; }

        .card-rank { font-size: 1.1rem; line-height: 1; }
        .card-suit { font-size: 1.2rem; align-self: flex-end; line-height: 1; }

        /* 筹码样式 */
        .chip-stack {
            position: absolute;
            font-size: 0.8rem;
            color: white;
            font-weight: bold;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            pointer-events: none;
        }
        .chip {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.5);
            margin-top: -15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .chip-label { margin-bottom: 2px; text-shadow: 1px 1px 2px black; }

        /* 操作面板 */
        #controls {
            width: 100%;
            max-width: 900px;
            background: #222;
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            border-top: 2px solid #444;
            border-radius: 10px;
            margin-top: 10px;
            flex-shrink: 0;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            background: #444;
            color: white;
        }
        button:hover:not(:disabled) { background: #666; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button.primary { background: #2e7d32; }
        button.primary:hover:not(:disabled) { background: #388e3c; }
        button.danger { background: #c62828; }
        button.danger:hover:not(:disabled) { background: #d32f2f; }
        button.warning { background: #f57c00; }
        button.warning:hover:not(:disabled) { background: #ff9800; }
        button.info { background: #0288d1; }
        button.info:hover:not(:disabled) { background: #03a9f4; }

        .mobile-only { display: none; }

        #raise-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #333;
            padding: 5px 15px;
            border-radius: 20px;
        }
        input[type="range"] { cursor: pointer; }
        #raise-amount-input {
            width: 80px;
            background: #222;
            border: 1px solid #555;
            color: #ffd700;
            font-weight: bold;
            border-radius: 5px;
            padding: 2px 5px;
            text-align: center;
            outline: none;
        }
        #raise-amount-input::-webkit-inner-spin-button,
        #raise-amount-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        #raise-amount-input {
            -moz-appearance: textfield;
        }

        /* 弹窗 */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal {
            background: #333;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            text-align: center;
            border: 2px solid #555;
        }
        .modal h2 { margin-bottom: 20px; color: #ffd700; }
        .form-group { margin-bottom: 15px; text-align: left; }
        .form-group label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
        .form-group input {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            background: #222;
            color: white;
        }
        .hidden { display: none !important; }

        /* 提示信息 */
        #game-msg {
            position: absolute;
            top: 40%; /* 移动到 40% 避免与顶部 AI 2 重叠 */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 10px rgba(0,0,0,1);
            z-index: 100; /* 提高层级 */
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #game-msg.show { opacity: 1; }

        /* 响应式 */
        @media (max-width: 900px) {
            #main-layout { flex-direction: column; }
            .mobile-only { display: inline-block; }
            #close-log.mobile-only { display: flex; align-items: center; justify-content: center; }

            #game-log-container { 
                display: none !important; 
                visibility: hidden; 
                width: 0; 
                height: 0; 
                position: absolute;
            } 
            #game-log-container.active-mobile {
                display: flex !important;
                visibility: visible;
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100dvh;
                z-index: 200;
                background: rgba(0,0,0,0.95);
                margin: 0;
                border: none;
                border-radius: 0;
            }
            #game-log-header {
                padding: 15px;
                font-size: 1.2rem;
            }
            #game-log-body {
                flex: 1;
                font-size: 1rem;
            }

            #game-container { 
                height: 100dvh; 
                width: 100vw; 
                flex: 1;
                padding: 0;
            }
            #poker-table { 
                width: 98%; 
                border-radius: 40px; 
                border-width: 6px; 
                max-height: 40vh;
                margin-top: 50px;
                aspect-ratio: 1 / 1;
            }
            .player-seat { width: 75px; }
            .player-info { padding: 4px; }
            .player-name { font-size: 0.65rem; }
            .player-chips { font-size: 0.75rem; }
            .card { width: 30px; height: 42px; }
            .card-rank { font-size: 0.75rem; }
            .card-suit { font-size: 0.85rem; }
            #controls { 
                padding: 15px 5px; 
                gap: 5px; 
                margin-top: auto;
                background: rgba(34, 34, 34, 0.98);
                width: 100%;
                z-index: 50;
                flex-wrap: wrap;
                justify-content: center;
            }
            button { 
                padding: 10px 5px; 
                font-size: 0.75rem; 
                flex: 1 1 30%; 
                min-width: 80px;
                height: 45px;
            }
            #raise-slider-container { 
                width: 100%; 
                justify-content: center; 
                order: -1; 
                margin-bottom: 10px;
                padding: 0 10px;
            }
            #raise-slider { flex: 1; }
            #raise-amount-input { width: 60px; height: 35px; font-size: 0.9rem; }
            
            /* 调整移动端座位布局 */
            .player-seat.left { left: 2px; }
            .player-seat.right { right: 2px; }
            .player-seat.top { top: -45px; }
            .player-seat.bottom { bottom: -45px; }

            /* 移动端筹码位置优化，避免重叠状态文字 */
            .player-seat.bottom .chip-stack { bottom: 105%; left: 50%; transform: translateX(-50%); }
            .player-seat.top .chip-stack { top: 105%; left: 50%; transform: translateX(-50%); }
            .player-seat.left .chip-stack { left: 110%; top: 50%; transform: translateY(-50%); }
            .player-seat.right .chip-stack { right: 110%; top: 50%; transform: translateY(-50%); }
        }

        /* 针对超窄屏幕（竖屏） */
        @media (max-width: 450px) {
            #poker-table { aspect-ratio: 0.85 / 1; }
            .player-seat { width: 65px; }
            .card { width: 26px; height: 38px; }
            #pot-container { top: 10px; left: 10px; font-size: 0.8rem; padding: 4px 10px; }
            #community-cards { gap: 3px; }
        }

        @media (max-height: 600px) {
            #poker-table { max-height: 60vh; }
            #controls { padding: 5px; margin-top: 5px; }
            .player-seat { width: 80px; }
            .player-cards { height: 40px; }
            .card { width: 30px; height: 45px; }
        }

        /* 游戏日志面板 */
        #game-log-container {
            width: 300px;
            background: rgba(20, 20, 20, 0.95);
            border-left: 2px solid #444;
            display: flex;
            flex-direction: column;
            font-size: 0.9rem;
            color: #ccc;
            height: 100%;
            flex-shrink: 0;
        }
        #game-log-header {
            padding: 10px;
            background: #333;
            font-weight: bold;
            color: #ffd700;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
        }
        #game-log-body {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .log-entry {
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 3px;
            line-height: 1.4;
            word-break: break-all;
        }
        .log-entry.win { color: #4caf50; font-weight: bold; }
        .log-entry.loss { color: #f44336; }
        .log-entry.thought { color: #aaa; font-style: italic; font-size: 0.85rem; }
        .log-entry.action { color: #fff; }
        .log-entry.system { color: #ffd700; font-style: italic; }
    </style>
</head>
<body>

<div id="main-layout">
    <div id="game-container">
    <div id="poker-table">
        <div id="game-msg">轮到你行动</div>
        
        <div id="pot-container">底池: <span id="main-pot">0</span></div>

        <!-- 社区牌 -->
        <div id="community-cards"></div>

        <!-- 玩家位置 -->
        <div id="seat-0" class="player-seat bottom">
            <div class="player-status" id="status-0"></div>
            <div class="player-info">
                <div class="player-name" id="name-0">你 (玩家)</div>
                <div class="player-chips" id="chips-0">10000</div>
            </div>
            <div class="player-cards" id="cards-0"></div>
            <div class="chip-stack" id="bet-0"></div>
        </div>

        <div id="seat-1" class="player-seat left">
            <div class="player-status" id="status-1"></div>
            <div class="player-info">
                <div class="player-name" id="name-1">AI 1</div>
                <div class="player-chips" id="chips-1">10000</div>
            </div>
            <div class="player-cards" id="cards-1"></div>
            <div class="chip-stack" id="bet-1"></div>
        </div>

        <div id="seat-2" class="player-seat top">
            <div class="player-status" id="status-2"></div>
            <div class="player-info">
                <div class="player-name" id="name-2">AI 2</div>
                <div class="player-chips" id="chips-2">10000</div>
            </div>
            <div class="player-cards" id="cards-2"></div>
            <div class="chip-stack" id="bet-2"></div>
        </div>

        <div id="seat-3" class="player-seat right">
            <div class="player-status" id="status-3"></div>
            <div class="player-info">
                <div class="player-name" id="name-3">AI 3</div>
                <div class="player-chips" id="chips-3">10000</div>
            </div>
            <div class="player-cards" id="cards-3"></div>
            <div class="chip-stack" id="bet-3"></div>
        </div>
    </div>

    <!-- 操作面板 -->
    <div id="controls" class="hidden">
        <button id="btn-log" class="info mobile-only">日志</button>
        <button id="btn-fold" class="danger">弃牌</button>
        <button id="btn-check">看牌</button>
        <button id="btn-call">跟注 <span id="call-amount"></span></button>
        <div id="raise-slider-container">
            <input type="number" id="raise-amount-input" value="0">
            <input type="range" id="raise-slider" min="0" max="1000" step="50">
        </div>
        <button id="btn-raise" class="warning">加注</button>
        <button id="btn-allin" class="primary">全下</button>
    </div>

    </div>

    <!-- 游戏日志 -->
    <div id="game-log-container">
        <div id="game-log-header">
            <span>游戏日志</span>
            <span id="hand-number">局数: 0</span>
            <span id="close-log" class="mobile-only" style="cursor: pointer; font-size: 1.5rem;">&times;</span>
        </div>
        <div id="game-log-body">
            <div class="log-entry system">欢迎来到德州扑克！</div>
        </div>
    </div>
</div>

<!-- 设置模态框 -->
<div id="setup-modal" class="modal-overlay">
    <div class="modal">
        <h2>游戏设置</h2>
        <div class="form-group">
                <label>你的名字</label>
                <input type="text" id="player-name" value="你" placeholder="输入你的大名">
            </div>
            <div class="form-group">
            <label>起始筹码</label>
            <input type="number" id="start-chips" value="10000" min="1000" step="500">
        </div>
        <div class="form-group">
            <label>小盲注金额</label>
            <input type="number" id="small-blind" value="50" min="10" step="10">
        </div>
        <button id="start-game-btn" class="primary" style="width: 100%;">开始游戏</button>
    </div>
</div>

<!-- 结算模态框 -->
<div id="result-modal" class="modal-overlay hidden">
    <div class="modal">
        <h2 id="result-title">游戏结束</h2>
        <p id="result-body" style="margin-bottom: 20px; line-height: 1.6;"></p>
        <button id="restart-game-btn" class="primary" style="width: 100%;">重新开始</button>
    </div>
</div>

<script>
/**
 * 德州扑克核心引擎
 */

// 常量定义
const SUITS = ['♠', '♥', '♣', '♦'];
const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
const RANK_VALUES = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };

const HAND_TYPES = {
    ROYAL_FLUSH: 9,
    STRAIGHT_FLUSH: 8,
    FOUR_OF_A_KIND: 7,
    FULL_HOUSE: 6,
    FLUSH: 5,
    STRAIGHT: 4,
    THREE_OF_A_KIND: 3,
    TWO_PAIR: 2,
    PAIR: 1,
    HIGH_CARD: 0
};

const HAND_NAMES = ["高牌", "一对", "两对", "三条", "顺子", "同花", "葫芦", "四条", "同花顺", "皇家同花顺"];

// 游戏状态
let gameState = {
    players: [],
    deck: [],
    communityCards: [],
    pot: 0,
    currentBet: 0,
    minRaise: 0,
    dealerIndex: 0,
    currentPlayerIndex: 0,
    stage: 'preflop', // preflop, flop, turn, river, showdown
    smallBlind: 50,
    bigBlind: 100,
    handCount: 0,
    activePlayersCount: 0,
    lastRaiserIndex: -1,
    winners: []
};

/**
 * 卡牌类
 */
class Card {
    constructor(suit, rank) {
        this.suit = suit;
        this.rank = rank;
        this.value = RANK_VALUES[rank];
        this.color = (suit === '♥' || suit === '♦') ? 'red' : 'black';
    }
}

/**
 * 玩家类
 */
class Player {
    constructor(id, name, chips, isAI = true) {
        this.id = id;
        this.name = name;
        this.chips = chips;
        this.isAI = isAI;
        this.cards = [];
        this.currentBet = 0;
        this.isFolded = false;
        this.isAllIn = false;
        this.hasActed = false;
        this.totalContributed = 0; // 本局总投入，用于计算副池
        this.handResult = null;
        
        // AI 独立性格系统
        if (isAI) {
            this.refreshPersonality();
        }
    }

    // 独立思考：刷新 AI 的性格底色、激进度和稳定性
    refreshPersonality() {
        const personalities = ['tight-passive', 'loose-aggressive', 'balanced'];
        this.personality = personalities[Math.floor(Math.random() * personalities.length)];
        // 激进指数 (0-1)：0 为极度保守，1 为极度疯狂
        this.aggression = Math.random(); 
        // 稳定性 (0-1)：越低越容易在出牌中途“变脸”
        this.stability = 0.4 + Math.random() * 0.6; 
        // 实时情绪 (-0.5 到 0.5)：影响具体某一手牌的发挥
        this.mood = (Math.random() - 0.5); 
    }

    // 动态调整情绪
    updateMood() {
        // 每一次行动，AI 都有概率改变当下的主意
        const swing = (Math.random() - 0.5) * (1.1 - this.stability);
        this.mood = Math.max(-1, Math.min(1, this.mood + swing));
    }
}

/**
 * 牌型判定逻辑
 */
class HandEvaluator {
    static evaluate(cards) {
        const combinations = this.getCombinations(cards, 5);
        let bestHand = null;

        for (const combo of combinations) {
            const result = this.getHandStrength(combo);
            if (!bestHand || this.compareResults(result, bestHand) > 0) {
                bestHand = result;
            }
        }
        return bestHand;
    }

    // 获取所有5张牌的组合 (7选5)
    static getCombinations(array, k) {
        const result = [];
        const f = (start, combo) => {
            if (combo.length === k) {
                result.push([...combo]);
                return;
            }
            for (let i = start; i < array.length; i++) {
                combo.push(array[i]);
                f(i + 1, combo);
                combo.pop();
            }
        };
        f(0, []);
        return result;
    }

    static getHandStrength(cards) {
        const sorted = [...cards].sort((a, b) => b.value - a.value);
        const isFlush = new Set(sorted.map(c => c.suit)).size === 1;
        
        // 顺子判定 (处理 A2345)
        let isStraight = true;
        let straightHighValue = sorted[0].value;
        for (let i = 0; i < sorted.length - 1; i++) {
            if (sorted[i].value !== sorted[i+1].value + 1) {
                isStraight = false;
                break;
            }
        }
        // 特殊处理 A2345
        if (!isStraight && sorted[0].value === 14 && sorted[1].value === 5 && sorted[2].value === 4 && sorted[3].value === 3 && sorted[4].value === 2) {
            isStraight = true;
            straightHighValue = 5;
        }

        const counts = {};
        sorted.forEach(c => counts[c.value] = (counts[c.value] || 0) + 1);
        const countValues = Object.values(counts).sort((a, b) => b - a);
        const rankEntries = Object.entries(counts).map(([val, count]) => ({ val: parseInt(val), count })).sort((a, b) => b.count !== a.count ? b.count - a.count : b.val - a.val);

        if (isFlush && isStraight) {
            return { type: straightHighValue === 14 ? HAND_TYPES.ROYAL_FLUSH : HAND_TYPES.STRAIGHT_FLUSH, value: straightHighValue, kickers: [] };
        }
        if (countValues[0] === 4) {
            return { type: HAND_TYPES.FOUR_OF_A_KIND, value: rankEntries[0].val, kickers: [rankEntries[1].val] };
        }
        if (countValues[0] === 3 && countValues[1] === 2) {
            return { type: HAND_TYPES.FULL_HOUSE, value: rankEntries[0].val, kickers: [rankEntries[1].val] };
        }
        if (isFlush) {
            return { type: HAND_TYPES.FLUSH, value: 0, kickers: sorted.map(c => c.value) };
        }
        if (isStraight) {
            return { type: HAND_TYPES.STRAIGHT, value: straightHighValue, kickers: [] };
        }
        if (countValues[0] === 3) {
            return { type: HAND_TYPES.THREE_OF_A_KIND, value: rankEntries[0].val, kickers: [rankEntries[1].val, rankEntries[2].val] };
        }
        if (countValues[0] === 2 && countValues[1] === 2) {
            return { type: HAND_TYPES.TWO_PAIR, value: rankEntries[0].val, kickers: [rankEntries[1].val, rankEntries[2].val] };
        }
        if (countValues[0] === 2) {
            return { type: HAND_TYPES.PAIR, value: rankEntries[0].val, kickers: rankEntries.slice(1).map(e => e.val) };
        }
        return { type: HAND_TYPES.HIGH_CARD, value: 0, kickers: sorted.map(c => c.value) };
    }

    static compareResults(a, b) {
        if (a.type !== b.type) return a.type - b.type;
        if (a.value !== b.value) return a.value - b.value;
        for (let i = 0; i < a.kickers.length; i++) {
            if (a.kickers[i] !== b.kickers[i]) return a.kickers[i] - b.kickers[i];
        }
        return 0;
    }
}

/**
 * AI 决策类 - 高手增强版 (基于 GTO、位置意识、胜率与赔率)
 */
class AIPolicy {
    static decide(player, gameState) {
        // AI 在行动前更新一下当下的“心情”
        player.updateMood();

        const cards = [...player.cards, ...gameState.communityCards];
        const handEval = cards.length >= 5 ? HandEvaluator.evaluate(cards) : null;
        const strength = handEval ? handEval.type : 0;
        
        const callAmount = gameState.currentBet - player.currentBet;
        const totalPot = gameState.pot + callAmount;
        const potOdds = callAmount / (totalPot || 1);
        
        // 1. 位置评估 (相对庄家的位置)
        const relativePos = (player.id - gameState.dealerIndex + 4) % 4; 
        const isLatePos = (relativePos === 0 || relativePos === 3); 
        const isBlinds = (relativePos === 1 || relativePos === 2);

        // 2. 胜率估算 (2/4 法则 + 听牌质量)
        let equity = 0;
        let outs = 0;
        if (gameState.stage !== 'preflop' && gameState.stage !== 'showdown') {
            outs = this.calculateOuts(player.cards, gameState.communityCards);
            const multiplier = (gameState.stage === 'flop') ? 4 : 2;
            equity = (outs * multiplier) / 100;
            
            if (strength >= HAND_TYPES.THREE_OF_A_KIND) equity += 0.8;
            else if (strength >= HAND_TYPES.TWO_PAIR) equity += 0.6;
            else if (strength >= HAND_TYPES.PAIR) {
                if (this.isTopPair(player.cards, gameState.communityCards)) equity += 0.4;
                else equity += 0.15;
            }
        }

        // 3. 动态激进度：基础性格 + 激进指数 + 情绪波动
        let currentAggression = player.aggression + player.mood;
        if (player.personality === 'tight-passive') currentAggression -= 0.3;
        if (player.personality === 'loose-aggressive') currentAggression += 0.3;
        
        const rand = Math.random();

        // --- 前注圈 (Preflop) ---
        if (gameState.stage === 'preflop') {
            const power = this.evaluatePreflop(player.cards);
            
            // 计算入池意愿 (VPIP Score)
            let vpipScore = (power / 30) + (currentAggression * 0.4) + (isLatePos ? 0.15 : 0);
            
            if (vpipScore > 0.8) { // 强力进攻
                return (callAmount < player.chips * 0.4 && rand < 0.7) ? 'raise' : 'call';
            } else if (vpipScore > 0.5) { // 稳健入池
                if (callAmount > gameState.bigBlind * 4 && currentAggression < 0.6) return 'fold';
                return (callAmount === 0 && rand < currentAggression) ? 'raise' : 'call';
            } else if (vpipScore > 0.3) { // 边缘牌
                if (callAmount === 0) return (rand < 0.2) ? 'call' : 'fold';
                if (callAmount <= gameState.bigBlind) return 'call';
                return 'fold';
            }
            return 'fold';
        } 
        
        // --- 翻牌后 (Postflop) ---
        else {
            const isLastRaiser = gameState.lastRaiserIndex === player.id;
            
            // 计算行动激进度 (Postflop Aggression Score)
            // 考虑牌力、胜率、情绪、位置
            let actionScore = (equity * 0.6) + (currentAggression * 0.4) + (isLatePos ? 0.1 : 0);
            if (strength >= HAND_TYPES.THREE_OF_A_KIND) actionScore += 0.4;

            if (actionScore > 0.9) { // 极强/极激进
                if (gameState.currentBet === 0) return 'raise';
                return (rand < 0.6) ? 'raise' : 'call';
            } else if (actionScore > 0.6) { // 强牌/半诈唬
                if (gameState.currentBet === 0) return (rand < 0.7) ? 'raise' : 'check';
                if (potOdds < equity || rand < currentAggression * 0.3) return 'call';
                return 'fold';
            } else if (actionScore > 0.3) { // 中等牌/听牌
                if (gameState.currentBet === 0) return (rand < 0.2) ? 'raise' : 'check';
                if (potOdds < equity * 1.2) return 'call';
                return 'fold';
            }

            // 空气牌但有特殊情况 (C-Bet 或 偷池)
            if (gameState.currentBet === 0) {
                if ((isLastRaiser || isLatePos) && rand < currentAggression * 0.4) return 'raise';
                return 'check';
            }

            // 极低概率的纯诈唬 (主要发生在后位或情绪高涨时)
            if (isLatePos && currentAggression > 0.7 && rand < 0.1) return 'raise';

            return 'fold';
        }
    }

    // 计算补牌 (Outs) - 更精准
    static calculateOuts(holeCards, communityCards) {
        let outs = 0;
        const allCards = [...holeCards, ...communityCards];
        
        // 1. 同花听牌 (9 outs)
        const suits = {};
        allCards.forEach(c => suits[c.suit] = (suits[c.suit] || 0) + 1);
        let flushSuit = null;
        for (const [suit, count] of Object.entries(suits)) {
            if (count === 4) { flushSuit = suit; outs += 9; break; }
        }

        // 2. 顺子听牌
        const values = Array.from(new Set(allCards.map(c => c.value))).sort((a,b) => a-b);
        // 检查 A2345 顺子听牌
        const hasAce = values.includes(14);
        const lowValues = hasAce ? [1, ...values.filter(v => v < 14)] : values;
        
        let maxConnect = 0;
        for (let i = 0; i < values.length; i++) {
            let count = 1;
            for (let j = i + 1; j < values.length; j++) {
                if (values[j] === values[i] + (j - i)) count++;
                else break;
            }
            maxConnect = Math.max(maxConnect, count);
        }
        
        if (maxConnect === 4) {
            // 两头顺 (8 outs) 或 只有一头 (4 outs)
            // 简单处理：两头顺 8，卡顺 4
            const isOESD = this.isOESD(values);
            outs += isOESD ? 8 : 4;
        }

        // 3. 超额牌 (Overcards) - 翻牌到转牌时
        const communityMax = Math.max(...communityCards.map(c => c.value));
        holeCards.forEach(c => {
            if (c.value > communityMax) outs += 3; // 每一张超额牌约 3 outs
        });

        return Math.min(outs, 18);
    }

    // AI 心理活动描述
    static getThought(player, action) {
        const personalityMap = {
            'tight-passive': {
                'fold': ['牌太烂了，还是稳着点...', '这种赔率不值得冒险。', '等一手大牌再进。'],
                'call': ['跟注看看翻牌，希望运气好点。', '这个价格可以接受。'],
                'check': ['先看看情况...', '希望能免费看下一张。'],
                'raise': ['这把牌稳了！', '稍微加一点试试水。']
            },
            'loose-aggressive': {
                'fold': ['啧，这把没戏。', '换一局再收拾你们。'],
                'call': ['你以为你能吓走我？', '我也想看看你的牌。'],
                'check': ['让你先出招。', '过牌，等会再加注。'],
                'raise': ['直接拉满压力！', '这就是我的风格！', '诈唬？也许吧。']
            },
            'balanced': {
                'fold': ['概率上不支持跟注。', '放弃是明智的选择。'],
                'call': ['合理的跟注。', '按计划行事。'],
                'check': ['标准过牌。', '控制底池。'],
                'raise': ['价值下注。', '平衡我的范围。']
            }
        };

        const thoughts = personalityMap[player.personality] || personalityMap['balanced'];
        const list = thoughts[action] || ['思考中...'];
        return list[Math.floor(Math.random() * list.length)];
    }

    static isOESD(values) {
        // 简单判断是否为两头顺
        for (let i = 0; i <= values.length - 4; i++) {
            if (values[i+3] === values[i] + 3) {
                // 如果不是 A-high 或 5-high (避免一头顺)
                if (values[i] > 1 && values[i+3] < 14) return true;
            }
        }
        return false;
    }

    static isTopPair(holeCards, communityCards) {
        if (communityCards.length === 0) return false;
        const communityMax = Math.max(...communityCards.map(c => c.value));
        return holeCards.some(c => c.value === communityMax);
    }

    // 前注圈手牌强度评估 (1-30+)
    static evaluatePreflop(cards) {
        const v1 = cards[0].value;
        const v2 = cards[1].value;
        const isPair = v1 === v2;
        const isSuited = cards[0].suit === cards[1].suit;
        const high = Math.max(v1, v2);
        const low = Math.min(v1, v2);
        const gap = high - low;
        
        let score = high;
        if (isPair) score += 15; // 对子大幅加分
        if (isSuited) score += 4; // 同花加分
        if (gap === 1) score += 2; // 连张
        if (gap === 2) score += 1; // 隔张
        
        // 惩罚弱踢脚 A
        if (high === 14 && low < 8 && !isSuited && !isPair) score -= 2;
        
        return score;
    }
}


/**
 * 游戏主逻辑
 */
const Game = {
    init() {
        this.bindEvents();
    },

    bindEvents() {
        document.getElementById('start-game-btn').onclick = () => this.startGame();
        document.getElementById('restart-game-btn').onclick = () => {
            document.getElementById('result-modal').classList.add('hidden');
            document.getElementById('setup-modal').classList.remove('hidden');
        };

        // 玩家行动按钮
        document.getElementById('btn-fold').onclick = () => this.handlePlayerAction('fold');
        document.getElementById('btn-check').onclick = () => this.handlePlayerAction('check');
        document.getElementById('btn-call').onclick = () => this.handlePlayerAction('call');
        document.getElementById('btn-allin').onclick = () => this.handlePlayerAction('allin');
        document.getElementById('btn-raise').onclick = () => {
            const amount = parseInt(document.getElementById('raise-amount-input').value);
            this.handlePlayerAction('raise', amount);
        };

        // 手机端日志切换
        const logContainer = document.getElementById('game-log-container');
        const logBody = document.getElementById('game-log-body');
        document.getElementById('btn-log').onclick = () => {
            logContainer.classList.add('active-mobile');
            // 延迟一点点确保渲染后再滚动
            setTimeout(() => {
                logBody.scrollTop = logBody.scrollHeight;
            }, 50);
        };
        document.getElementById('close-log').onclick = (e) => {
            e.stopPropagation();
            logContainer.classList.remove('active-mobile');
        };

        const slider = document.getElementById('raise-slider');
        const input = document.getElementById('raise-amount-input');

        slider.oninput = (e) => {
            input.value = e.target.value;
        };

        input.oninput = (e) => {
            let val = parseInt(e.target.value) || 0;
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            
            // 只有当输入值在有效范围内时才同步滑动条
            // 但允许用户输入过程中的中间状态
            if (val >= min && val <= max) {
                slider.value = val;
            }
        };

        input.onblur = (e) => {
            let val = parseInt(e.target.value) || 0;
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            
            // 失去焦点时强制修正到有效范围
            if (val < min) val = min;
            if (val > max) val = max;
            
            input.value = val;
            slider.value = val;
        };
    },

    startGame() {
        const playerName = document.getElementById('player-name').value || '你';
        const startChips = parseInt(document.getElementById('start-chips').value) || 10000;
        const smallBlind = parseInt(document.getElementById('small-blind').value) || 50;

        gameState.players = [
            new Player(0, playerName, startChips, false),
            new Player(1, "AI 1", startChips, true),
            new Player(2, "AI 2", startChips, true),
            new Player(3, "AI 3", startChips, true)
        ];
        gameState.smallBlind = smallBlind;
        gameState.bigBlind = smallBlind * 2;
        gameState.dealerIndex = Math.floor(Math.random() * 4);

        document.getElementById('setup-modal').classList.add('hidden');
        document.getElementById('controls').classList.remove('hidden');
        
        // 确保 UI 已经根据 players 进行了第一次渲染
        this.updateUI();
        
        this.log('游戏开始！', 'system');
        this.startNewHand();
    },

    startNewHand() {
        // 重置状态
        gameState.handCount++;
        document.getElementById('hand-number').innerText = `局数: ${gameState.handCount}`;
        this.log(`--- 第 ${gameState.handCount} 局开始 ---`, 'system');

        gameState.deck = this.createDeck();
        this.shuffle(gameState.deck);
        gameState.communityCards = [];
        gameState.pot = 0;
        gameState.stage = 'preflop';
        gameState.currentBet = gameState.bigBlind;
        gameState.minRaise = gameState.bigBlind;
        gameState.lastRaiserIndex = -1;

        gameState.players.forEach(p => {
            p.cards = [];
            p.currentBet = 0;
            p.totalContributed = 0; // 重置本局投入
            p.isFolded = p.chips <= 0;
            p.isAllIn = false;
            p.hasActed = false;
            p.handResult = null;
            
            // 每一局开始，AI 都会刷新自己的性格和状态，增加多变性
            if (p.isAI && p.chips > 0) {
                p.refreshPersonality();
            }
        });

        // 移动庄家位
        gameState.dealerIndex = (gameState.dealerIndex + 1) % 4;
        while (gameState.players[gameState.dealerIndex].chips <= 0) {
            gameState.dealerIndex = (gameState.dealerIndex + 1) % 4;
        }

        // 强制小盲和大盲
        const sbIndex = (gameState.dealerIndex + 1) % 4;
        const bbIndex = (gameState.dealerIndex + 2) % 4;
        
        this.playerBet(gameState.players[sbIndex], gameState.smallBlind);
        this.log(`${gameState.players[sbIndex].name} 支付小盲注: ${gameState.smallBlind}`, 'action');
        this.playerBet(gameState.players[bbIndex], gameState.bigBlind);
        this.log(`${gameState.players[bbIndex].name} 支付大盲注: ${gameState.bigBlind}`, 'action');

        // 发牌
        gameState.players.forEach(p => {
            if (!p.isFolded) {
                p.cards.push(gameState.deck.pop(), gameState.deck.pop());
            }
        });

        gameState.currentPlayerIndex = (bbIndex + 1) % 4;
        this.updateUI();
        this.processTurn();
    },

    createDeck() {
        const deck = [];
        for (const suit of SUITS) {
            for (const rank of RANKS) {
                deck.push(new Card(suit, rank));
            }
        }
        return deck;
    },

    shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    },

    playerBet(player, amount) {
        const actualAmount = Math.min(player.chips, amount);
        player.chips -= actualAmount;
        player.currentBet += actualAmount;
        player.totalContributed += actualAmount;
        gameState.pot += actualAmount;
        if (player.chips === 0) player.isAllIn = true;
        
        if (player.currentBet > gameState.currentBet) {
            gameState.minRaise = player.currentBet - gameState.currentBet;
            gameState.currentBet = player.currentBet;
            gameState.lastRaiserIndex = player.id;
            // 当有人加注，其他未弃牌且非全下的玩家需要重新行动
            gameState.players.forEach(p => {
                if (!p.isFolded && !p.isAllIn) p.hasActed = false;
            });
        }
        player.hasActed = true;
    },

    async processTurn() {
        const activePlayers = gameState.players.filter(p => !p.isFolded && !p.isAllIn);
        
        // 检查这一轮是否结束
        const roundFinished = gameState.players.every(p => 
            p.isFolded || p.isAllIn || (p.hasActed && p.currentBet === gameState.currentBet)
        );

        if (roundFinished) {
            await this.nextStage();
            return;
        }

        const current = gameState.players[gameState.currentPlayerIndex];
        if (current.isFolded || current.isAllIn) {
            this.moveToNextPlayer();
            this.processTurn();
            return;
        }

        this.updateUI();

        if (current.isAI) {
            // 在 UI 上显示“思考中...”
            const statusEl = document.getElementById(`status-${current.id}`);
            if (statusEl) statusEl.innerText = "思考中...";
            
            // 随机思考时间，模拟 AI 在“思考”
            const thinkTime = 800 + Math.random() * 2000;
            await new Promise(r => setTimeout(r, thinkTime)); 
            
            const action = AIPolicy.decide(current, gameState);
            const thought = AIPolicy.getThought(current, action);
            
            // 有概率在日志中输出 AI 的“心理活动”
            if (Math.random() < 0.4) {
                this.log(`${current.name}: "${thought}"`, 'thought');
            }
            
            this.handleAIAction(current, action);
        } else {
            this.showMessage("轮到你行动");
            this.enableControls(true);
        }
    },

    handleAIAction(player, action) {
        const callAmount = gameState.currentBet - player.currentBet;
        
        if (action === 'fold' && callAmount > 0) {
            player.isFolded = true;
            this.log(`${player.name} 弃牌`, 'action');
            this.showMessage(`${player.name} 弃牌`);
        } else if (action === 'raise') {
            const minRaiseAmt = gameState.currentBet + gameState.minRaise;
            const potSize = gameState.pot;
            const rand = Math.random();
            let targetBet = minRaiseAmt;
            
            // 更加多样化的下注尺度
            if (gameState.stage === 'preflop') {
                // 翻牌前：通常是 3x 盲注或 3x 上一次加注
                targetBet = gameState.currentBet === gameState.bigBlind ? 
                    gameState.bigBlind * 3 : gameState.currentBet * 2.5;
            } else {
                // 翻牌后：根据底池大小下注
                if (rand < 0.25) {
                    targetBet = gameState.currentBet + Math.floor(potSize * 0.33); // 1/3 池 (试探/干燥面)
                } else if (rand < 0.6) {
                    targetBet = gameState.currentBet + Math.floor(potSize * 0.5);  // 1/2 池 (标准)
                } else if (rand < 0.9) {
                    targetBet = gameState.currentBet + Math.floor(potSize * 0.75); // 3/4 池 (价值/保护)
                } else {
                    targetBet = gameState.currentBet + potSize; // 满池 (强力挤压)
                }
            }
            
            // 确保加注额合法
            targetBet = Math.max(minRaiseAmt, Math.floor(targetBet));
            targetBet = Math.min(targetBet, player.chips + player.currentBet);
            
            const actualBetNeeded = targetBet - player.currentBet;
            this.playerBet(player, actualBetNeeded);
            
            const isAllIn = player.isAllIn;
            this.log(`${player.name} ${isAllIn ? '全下' : '加注'} 到 ${player.currentBet}`, 'action');
            this.showMessage(`${player.name} ${isAllIn ? '全下!' : '加注'}`);
        } else if (action === 'call' || (action === 'check' && callAmount === 0)) {
            const isCall = callAmount > 0;
            this.playerBet(player, callAmount);
            const msg = isCall ? `${player.name} 跟注 ${callAmount}` : `${player.name} 过牌`;
            this.log(msg, 'action');
            this.showMessage(isCall ? `${player.name} 跟注` : `${player.name} 过牌`);
        } else {
            // 后备逻辑
            if (callAmount === 0) {
                this.playerBet(player, 0);
                this.log(`${player.name} 过牌`, 'action');
                this.showMessage(`${player.name} 过牌`);
            } else if (player.chips <= callAmount) {
                this.playerBet(player, player.chips);
                this.log(`${player.name} 全下!`, 'action');
                this.showMessage(`${player.name} 全下`);
            } else {
                player.isFolded = true;
                this.log(`${player.name} 弃牌`, 'action');
                this.showMessage(`${player.name} 弃牌`);
            }
        }

        this.moveToNextPlayer();
        this.processTurn();
    },

    handlePlayerAction(action, amount = 0) {
        const player = gameState.players[0];
        const callAmount = gameState.currentBet - player.currentBet;

        if (action === 'fold') {
            player.isFolded = true;
            this.log(`你 弃牌`, 'action');
        } else if (action === 'check') {
            this.playerBet(player, 0);
            this.log(`你 过牌`, 'action');
        } else if (action === 'call') {
            this.playerBet(player, callAmount);
            this.log(`你 跟注 ${callAmount}`, 'action');
        } else if (action === 'allin') {
            this.playerBet(player, player.chips);
            this.log(`你 全下!`, 'action');
        } else if (action === 'raise') {
            const actualRaise = amount - player.currentBet;
            this.playerBet(player, actualRaise);
            this.log(`你 加注到 ${player.currentBet}`, 'action');
        }

        this.enableControls(false);
        this.moveToNextPlayer();
        this.processTurn();
    },

    moveToNextPlayer() {
        gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % 4;
    },

    async nextStage() {
        // 重置本轮下注
        gameState.players.forEach(p => {
            p.currentBet = 0;
            p.hasActed = false;
        });
        gameState.currentBet = 0;
        gameState.minRaise = gameState.bigBlind;

        const notFolded = gameState.players.filter(p => !p.isFolded);
        if (notFolded.length === 1) {
            this.resolveWinner(notFolded[0]);
            return;
        }

        if (gameState.stage === 'preflop') {
            gameState.stage = 'flop';
            gameState.communityCards.push(gameState.deck.pop(), gameState.deck.pop(), gameState.deck.pop());
            this.log(`--- 翻牌圈 (Flop) ---`, 'system');
        } else if (gameState.stage === 'flop') {
            gameState.stage = 'turn';
            gameState.communityCards.push(gameState.deck.pop());
            this.log(`--- 转牌圈 (Turn) ---`, 'system');
        } else if (gameState.stage === 'turn') {
            gameState.stage = 'river';
            gameState.communityCards.push(gameState.deck.pop());
            this.log(`--- 河牌圈 (River) ---`, 'system');
        } else if (gameState.stage === 'river') {
            this.log(`--- 摊牌 (Showdown) ---`, 'system');
            this.showdown();
            return;
        }

        // 检查是否所有人都全下了（或者只有一人没全下）
        const canBet = gameState.players.filter(p => !p.isFolded && !p.isAllIn);
        if (canBet.length <= 1) {
            this.updateUI();
            await new Promise(r => setTimeout(r, 1000));
            this.nextStage();
            return;
        }

        gameState.currentPlayerIndex = (gameState.dealerIndex + 1) % 4;
        this.updateUI();
        this.processTurn();
    },

    showdown() {
        gameState.stage = 'showdown';
        this.showMessage("正在摊牌结算...", 3000);
        const activePlayers = gameState.players.filter(p => !p.isFolded);
        
        activePlayers.forEach(p => {
            p.handResult = HandEvaluator.evaluate([...p.cards, ...gameState.communityCards]);
        });

        // 复杂的边池计算逻辑
        const winnersInfo = this.calculatePots(activePlayers);
        
        this.updateUI();
        
        winnersInfo.forEach(info => {
            this.log(`${info.player.name} 赢得了 ${info.amount} (${HAND_NAMES[info.player.handResult.type]})`, 'win');
        });

        // 记录其他人的损益
        gameState.players.forEach(p => {
            if (p.totalContributed > 0) {
                const winInfo = winnersInfo.find(wi => wi.player.id === p.id);
                const net = (winInfo ? winInfo.amount : 0) - p.totalContributed;
                if (net < 0) {
                    this.log(`${p.name} 输掉了 ${Math.abs(net)}`, 'loss');
                }
            }
        });
        
        let resultMsg = winnersInfo.map(info => 
            `${info.player.name} (${HAND_NAMES[info.player.handResult.type]}) 赢得了 ${info.amount}`
        ).join('\n');
        
        // 缩短一点等待时间，让节奏更紧凑
        setTimeout(() => {
            this.checkGameEnd(resultMsg);
        }, 3000);
    },

    // 边池计算核心算法
    calculatePots(activePlayers) {
        let remainingPot = gameState.pot;
        const results = [];
        const sortedPlayers = [...activePlayers].sort((a, b) => HandEvaluator.compareResults(b.handResult, a.handResult));

        // 复制一份投入数据，避免修改原对象
        const contributions = gameState.players.map(p => ({ id: p.id, amount: p.totalContributed }));
        
        while (remainingPot > 0) {
            // 找到当前最强牌型的玩家（可能有多个平局）
            const bestHand = sortedPlayers.find(p => !p.receivedPot);
            if (!bestHand) break;

            const tiePlayers = sortedPlayers.filter(p => 
                !p.receivedPot && HandEvaluator.compareResults(p.handResult, bestHand.handResult) === 0
            );

            // 计算这些赢家能从底池中分走多少
            let potForThisRank = 0;
            tiePlayers.forEach(winner => {
                const winLimit = winner.totalContributed;
                contributions.forEach(contrib => {
                    const take = Math.min(contrib.amount, winLimit / tiePlayers.length);
                    // 实际上逻辑应为：赢家可以从每个人那里赢取不超过自己投入的金额
                });
            });

            // 简化版边池：按投入比例分配
            // 真正的德州边池较为复杂，这里采用：赢家按顺序分走他们应得的部分
            const winners = tiePlayers;
            let currentLevelPot = 0;
            
            // 找到这组赢家中投入最少的
            const minContribution = Math.min(...winners.map(w => w.totalContributed));
            
            // 从底池中提取这部分
            contributions.forEach(c => {
                const extract = Math.min(c.amount, minContribution);
                currentLevelPot += extract;
                c.amount -= extract;
                remainingPot -= extract;
            });

            const share = Math.floor(currentLevelPot / winners.length);
            winners.forEach(w => {
                w.chips += share;
                results.push({ player: w, amount: share });
                w.receivedPot = true; // 标记已参与分配
            });

            // 如果还有剩余（除不尽），给第一个赢家
            if (currentLevelPot % winners.length > 0) {
                winners[0].chips += currentLevelPot % winners.length;
            }
        }
        
        // 清理标记
        gameState.players.forEach(p => p.receivedPot = false);
        return results;
    },

    resolveWinner(winner) {
        const net = gameState.pot - winner.totalContributed;
        winner.chips += gameState.pot;
        this.updateUI();
        this.log(`${winner.name} 赢得了底池 ${gameState.pot} (其他玩家弃牌)`, 'win');
        
        // 记录其他人的损益
        gameState.players.forEach(p => {
            if (p.id !== winner.id && p.totalContributed > 0) {
                this.log(`${p.name} 输掉了 ${p.totalContributed}`, 'loss');
            }
        });

        this.showMessage(`${winner.name} 赢得了底池 ${gameState.pot} (其他玩家弃牌)`);
        setTimeout(() => {
            this.checkGameEnd(`${winner.name} 赢得了底池`);
        }, 2000);
    },

    checkGameEnd(lastHandMsg) {
        const alivePlayers = gameState.players.filter(p => p.chips > 0);
        if (alivePlayers.length === 1) {
            const modal = document.getElementById('result-modal');
            const title = document.getElementById('result-title');
            const body = document.getElementById('result-body');
            
            modal.classList.remove('hidden');
            title.innerText = alivePlayers[0].id === 0 ? "恭喜你赢了！" : "游戏结束";
            body.innerText = `${alivePlayers[0].name} 赢得了所有筹码！\n\n${lastHandMsg}`;
        } else if (gameState.players[0].chips <= 0) {
            const modal = document.getElementById('result-modal');
            const title = document.getElementById('result-title');
            const body = document.getElementById('result-body');
            
            modal.classList.remove('hidden');
            title.innerText = "你输了";
            body.innerText = `你的筹码已输光。\n\n${lastHandMsg}`;
        } else {
            this.startNewHand();
        }
    },

    updateUI() {
        // 更新公共牌
        const commContainer = document.getElementById('community-cards');
        commContainer.innerHTML = '';
        gameState.communityCards.forEach(card => {
            commContainer.appendChild(this.createCardUI(card));
        });

        // 更新底池
        document.getElementById('main-pot').innerText = gameState.pot;

        // 更新玩家信息
        gameState.players.forEach((p, i) => {
            const seat = document.getElementById(`seat-${i}`);
            const nameEl = document.getElementById(`name-${i}`);
            const chipsEl = document.getElementById(`chips-${i}`);
            const statusEl = document.getElementById(`status-${i}`);
            const cardsEl = document.getElementById(`cards-${i}`);
            const betEl = document.getElementById(`bet-${i}`);

            nameEl.innerText = p.name;
            chipsEl.innerText = p.chips;
            seat.className = `player-seat ${this.getSeatClass(i)} ${gameState.currentPlayerIndex === i ? 'active' : ''}`;
            
            let statusText = "";
            if (p.isFolded) {
                statusText = "弃牌";
                seat.style.opacity = "0.5";
            } else {
                seat.style.opacity = "1";
                if (p.isAllIn) statusText = "全下";
                else if (gameState.dealerIndex === i) statusText = "庄家 (D)";
            }
            statusEl.innerText = statusText;

            // 渲染手牌
            cardsEl.innerHTML = '';
            if (!p.isFolded && p.cards.length > 0) {
                p.cards.forEach(card => {
                    // 只有玩家自己的牌或摊牌阶段才显示
                    const hidden = (p.isAI && gameState.stage !== 'showdown');
                    cardsEl.appendChild(this.createCardUI(card, hidden));
                });
            }

            // 渲染下注筹码
            betEl.innerHTML = '';
            if (p.currentBet > 0) {
                betEl.innerHTML = `<span class="chip-label">${p.currentBet}</span>`;
                const chipCount = Math.min(5, Math.ceil(p.currentBet / 100));
                for(let c=0; c<chipCount; c++) {
                    const chip = document.createElement('div');
                    chip.className = 'chip';
                    chip.style.backgroundColor = this.getChipColor(p.currentBet);
                    betEl.appendChild(chip);
                }
            }
        });

        // 更新操作面板
        if (gameState.currentPlayerIndex === 0) {
            const p = gameState.players[0];
            const callAmt = gameState.currentBet - p.currentBet;
            
            document.getElementById('btn-check').classList.toggle('hidden', callAmt > 0);
            document.getElementById('btn-call').classList.toggle('hidden', callAmt === 0 || p.chips <= callAmt);
            document.getElementById('call-amount').innerText = callAmt;
            
            const minRaise = gameState.currentBet + gameState.minRaise;
            const canRaise = p.chips > callAmt + gameState.minRaise;
            
            document.getElementById('raise-slider-container').classList.toggle('hidden', !canRaise);
            document.getElementById('btn-raise').classList.toggle('hidden', !canRaise);
            
            if (canRaise) {
                const slider = document.getElementById('raise-slider');
                slider.min = minRaise;
                slider.max = p.chips + p.currentBet;
                slider.value = minRaise;
                document.getElementById('raise-amount-input').value = minRaise;
            }
        }
    },

    createCardUI(card, hidden = false) {
        const el = document.createElement('div');
        el.className = `card ${hidden ? 'hidden' : card.color}`;
        if (!hidden) {
            el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
        }
        return el;
    },

    getSeatClass(i) {
        return ['bottom', 'left', 'top', 'right'][i];
    },

    getChipColor(amt) {
        if (amt >= 1000) return '#d32f2f'; // 红
        if (amt >= 500) return '#1976d2';  // 蓝
        if (amt >= 100) return '#388e3c';  // 绿
        return '#fbc02d'; // 黄
    },

    enableControls(enabled) {
        const btns = document.querySelectorAll('#controls button');
        btns.forEach(b => b.disabled = !enabled);
    },

    showMessage(text) {
        const msg = document.getElementById('game-msg');
        msg.innerText = text;
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), 2000);
    },

    log(text, type = 'action') {
        const logBody = document.getElementById('game-log-body');
        if (!logBody) return; // 移动端可能隐藏
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.innerText = text;
        logBody.appendChild(entry);
        logBody.scrollTop = logBody.scrollHeight;
    }
};

// 初始化游戏
    Game.init();

    // 注册 Service Worker (PWA)
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('SW registered'))
                .catch(err => console.log('SW registration failed', err));
        });
    }
</script>

</body>
</html>
